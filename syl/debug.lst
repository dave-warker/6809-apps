                      (    ./src/syl.asm):00001         ; "syl.asm" - main file for 6809 Syl LISP by Dave Warker
                      (    ./src/syl.asm):00002         ; An attempt at a basic LISP 1.5ish LISP for the 6809 because (I have no idea.)
                      (    ./src/syl.asm):00003         ;
                      (    ./src/syl.asm):00004         ; MEMORY MAP FOR G6CC HARDWARE
                      (    ./src/syl.asm):00005         ; DEBUG                                                                                   EPROM
                      (    ./src/syl.asm):00006         ; $0000 +---------------------------------------+ $0000
                      (    ./src/syl.asm):00007         ;               |                                                                               |
                      (    ./src/syl.asm):00008         ;               | ATOM Name Pool                                                |
                      (    ./src/syl.asm):00009         ;               |                                                                               |
                      (    ./src/syl.asm):00010         ; $0800 +---------------------------------------+ $0800 <- DP
                      (    ./src/syl.asm):00011         ;               | Vars & CPU Stack                                              |
                      (    ./src/syl.asm):00012         ;               |+-------------------------------------+|
                      (    ./src/syl.asm):00013         ;               || Garbage Collector Mark Pool             ||
                      (    ./src/syl.asm):00014         ;               |+-------------------------------------+|
                      (    ./src/syl.asm):00015         ;               || Interpreter Stack                               ||           <- S
                      (    ./src/syl.asm):00016         ;               |+-------------------------------------+|
                      (    ./src/syl.asm):00017         ; $1000 +---------------------------------------+ $1000
                      (    ./src/syl.asm):00018         ;               | Root Context Stack                                    |               <- U
                      (    ./src/syl.asm):00019         ; $1400 +---------------------------------------+ $1400
                      (    ./src/syl.asm):00020         ;               |                                                                               |
                      (    ./src/syl.asm):00021         ;               | CONS Cell Pool                                                |
                      (    ./src/syl.asm):00022         ;               |                                                                               |
                      (    ./src/syl.asm):00023         ; $7000 +---------------------------------------+ $7F00
                      (    ./src/syl.asm):00024         ;               | Syl Interpreter Code (Debug Build)    |
                      (    ./src/syl.asm):00025         ; $7F00 +---------------------------------------+ $7F00
                      (    ./src/syl.asm):00026         ;               | Reserved for Demon Debugger                   |
                      (    ./src/syl.asm):00027         ; $8000 +---------------------------------------+ $8000
                      (    ./src/syl.asm):00028         ;
                      (    ./src/syl.asm):00029         ; REGISTER USAGE
                      (    ./src/syl.asm):00030         ;  DP   = points to start of VARS area
                      (    ./src/syl.asm):00031         ;  S    = Interpreter CPU Stack Pointer
                      (    ./src/syl.asm):00032         ;  U    = Root Pointers Stack Pointer for GC
                      (    ./src/syl.asm):00033         ;  X    = Scratch, preferred to pass CONS Cell Slot Ref arguments
                      (    ./src/syl.asm):00034         ;  Y,D  = Scratch
                      (    ./src/syl.asm):00035         ; Don't expect the D register to be preserved unless stated otherwise.
                      (    ./src/syl.asm):00036         
                      (    ./src/syl.asm):00037                                 pragma  6809,dollarnotlocal,cescapes
                      (    ./src/syl.asm):00038         
                      (    ./src/syl.asm):00043         
                      (    ./src/syl.asm):00044         ;@@@
                      (    ./src/syl.asm):00045         ;@@@ EQUATES
                      (    ./src/syl.asm):00046         ;@@@
                      (    ./src/syl.asm):00047         
                      (    ./src/syl.asm):00048         ; Metadata
     0001             (    ./src/syl.asm):00049         SYL_VER                         equ             1                                                               ;major version
     0003             (    ./src/syl.asm):00050         SYL_REV                         equ             3                                                               ;minor revision
                      (    ./src/syl.asm):00051         
                      (    ./src/syl.asm):00052         ; Memory Map
     0000             (    ./src/syl.asm):00053         ATOM_POOL_ORG           equ             $0000                                                   ;ATOM names pool (MUST BE $0000!)
     0800             (    ./src/syl.asm):00054         ATOM_POOL_SIZE          equ             $0800
     0800             (    ./src/syl.asm):00055         ATOM_POOL_END           equ             ATOM_POOL_ORG+ATOM_POOL_SIZE
     0800             (    ./src/syl.asm):00056         VARS_ORG                        equ             ATOM_POOL_END                                   ;Variables + CPU Stack
     0800             (    ./src/syl.asm):00057         VARS_SIZE                       equ             $0800
     1000             (    ./src/syl.asm):00058         VARS_END                        equ             VARS_ORG+VARS_SIZE
     1000             (    ./src/syl.asm):00059         VARS_STACK_TOP          equ             VARS_END                                                ;initial stack pointer
     1000             (    ./src/syl.asm):00060         ROOT_STACK_ORG          equ             VARS_END                                                ;GC Root Pointers Stack
     0400             (    ./src/syl.asm):00061         ROOT_STACK_SIZE         equ             $0400
     1400             (    ./src/syl.asm):00062         ROOT_STACK_END          equ             ROOT_STACK_ORG+ROOT_STACK_SIZE
     1400             (    ./src/syl.asm):00063         ROOT_STACK_TOP          equ             ROOT_STACK_END
     1400             (    ./src/syl.asm):00064         CONS_POOL_ORG           equ             ROOT_STACK_END                                  ;CONS Cells Pool
                      (    ./src/syl.asm):00065                 IFDEF DEBUG
     7000             (    ./src/syl.asm):00066         CONS_POOL_END           equ             $7000                                                   ;end in DEBUG build
     7000             (    ./src/syl.asm):00067         CODE_ORG                        equ             CONS_POOL_END                                   ;Interpreter Code area (in RAM)
     7F00             (    ./src/syl.asm):00068         CODE_END                        equ             $7F00                                                   ;end address (below Demon vars)
     0F00             (    ./src/syl.asm):00069         CODE_SIZE                       equ             CODE_END-CODE_ORG
                      (    ./src/syl.asm):00070                 ELSE
0000                  (    ./src/syl.asm):00071         CONS_POOL_END           equ             $7F00                                                   ;end in EPROM build
0000                  (    ./src/syl.asm):00072         CODE_ORG                        equ             $D000                                                   ;Interpreter Code arera (in EPROM)
0000                  (    ./src/syl.asm):00073         CODE_SIZE                       equ             $1000
0000                  (    ./src/syl.asm):00074         CODE_END                        equ             CODE_ORG+CODE_SIZE
                      (    ./src/syl.asm):00075                 ENDIF
     5C00             (    ./src/syl.asm):00076         CONS_POOL_SIZE          equ             CONS_POOL_END-CONS_POOL_ORG
                      (    ./src/syl.asm):00077         
                      (    ./src/syl.asm):00078         ; Console
     000A             (    ./src/syl.asm):00079         NL                                      equ             LF                                                              ;newline character
     0050             (    ./src/syl.asm):00080         CON_BUF_SIZE            equ             80                                                              ;size of the line input buffer
     FFFF             (    ./src/syl.asm):00081         CON_BUF_EMPTY           equ             -1                                                              ;next char offset when buffer is empty
                      (    ./src/syl.asm):00082         
     0028             (    ./src/syl.asm):00083         TOK_LPAR                        equ             '('                                                             ;token for left paren (
     0029             (    ./src/syl.asm):00084         TOK_RPAR                        equ             ')'                                                             ; right paren )
     002E             (    ./src/syl.asm):00085         TOK_DOT                         equ             '.'                                                             ; dot separator .
     0027             (    ./src/syl.asm):00086         TOK_QUOTE                       equ             SQUOT                                                   ; quote operator '
     0030             (    ./src/syl.asm):00087         TOK_INT                         equ             '0'                                                             ; integer value
     0023             (    ./src/syl.asm):00088         TOK_ATOM                        equ             '#'                                                             ; atom reference
                      (    ./src/syl.asm):00089         
     0001             (    ./src/syl.asm):00090         CC_C                            equ             $01                                                             ;Carry flag in condition code register
     0002             (    ./src/syl.asm):00091         CC_V                            equ             $02                                                             ;oVerflow flag
     0004             (    ./src/syl.asm):00092         CC_Z                            equ             $04                                                             ;Zero flag
     0008             (    ./src/syl.asm):00093         CC_N                            equ             $08                                                             ;Negative flag
     0010             (    ./src/syl.asm):00094         CC_I                            equ             $10                                                             ;Interrupt flag
     0020             (    ./src/syl.asm):00095         CC_H                            equ             $20                                                             ;Half carry flag
     0040             (    ./src/syl.asm):00096         CC_F                            equ             $40                                                             ;Fast interrupt flag
     0080             (    ./src/syl.asm):00097         CC_E                            equ             $80                                                             ;Entire register set flag
                      (    ./src/syl.asm):00098         
                      (    ./src/syl.asm):00099         ;@@@
                      (    ./src/syl.asm):00100         ;@@@ CONS CELLS
                      (    ./src/syl.asm):00101         ;@@@
                      (    ./src/syl.asm):00102         ;
                      (    ./src/syl.asm):00103         ; CONS CELL SLOT VALUES:
                      (    ./src/syl.asm):00104         ; $0000 - $07FF: ATOM Name Reference ($0000 = NIL)
                      (    ./src/syl.asm):00105         ; $0800 - $0FFF: Refs to Built-In Functions (BIVs, BIFs, BIQs)
                      (    ./src/syl.asm):00106         ; $1400 - $7FFC: CONS Cell References
                      (    ./src/syl.asm):00107         ; $8000 - $FFFF: 15 bit Signed Integers
                      (    ./src/syl.asm):00108         ;
                      (    ./src/syl.asm):00109         ; NOTE: NIL ATOM *must* be the first allocated to ensure it's ATOM
                      (    ./src/syl.asm):00110         ; value is 0! Using this setup ATOM and CONS refs are the same as
                      (    ./src/syl.asm):00111         ; their actual memory address which makes lots of stuff easier.
                      (    ./src/syl.asm):00112         ; The address range used by VARS is used for built-ins and are
                      (    ./src/syl.asm):00113         ; the offset from bis$base to the actual 6809 code.
                      (    ./src/syl.asm):00114         
     0002             (    ./src/syl.asm):00115         CC_SLOT_SIZE            equ             2                                                               ;size of a slot in a CONS Cell
     0004             (    ./src/syl.asm):00116         CC_SIZE                         equ             2*CC_SLOT_SIZE                                  ;size of a Cell (car + cdr)
     0000             (    ./src/syl.asm):00117         CC_CAR_OFF                      equ             0*CC_SLOT_SIZE                                  ;offset to CAR slot
     0002             (    ./src/syl.asm):00118         CC_CDR_OFF                      equ             1*CC_SLOT_SIZE                                  ;offset to CDR slot
                      (    ./src/syl.asm):00119         ;
     8000             (    ./src/syl.asm):00120         CCS_TYPE_MASK           equ             $8000                                                   ;mask for slot type
     0000             (    ./src/syl.asm):00121         CCS_TYPE_REF            equ             $0000                                                   ; value for references (ATOM or CONS)
     8000             (    ./src/syl.asm):00122         CCS_TYPE_INT            equ             $8000                                                   ; value for 15 bit signed integer
                      (    ./src/syl.asm):00123         ;
     7FFF             (    ./src/syl.asm):00124         CCS_INT_MASK            equ             $7FFF                                                   ;mask for integer value
     C001             (    ./src/syl.asm):00125         CCS_INT_MIN                     equ             -16383                                                  ;smallest integer
     3FFF             (    ./src/syl.asm):00126         CCS_INT_MAX                     equ             16383                                                   ;largest integer
                      (    ./src/syl.asm):00127         ;
     0000             (    ./src/syl.asm):00128         CCS_REF_NIL                     equ             ATOM_POOL_ORG                                   ;should be 0
     0800             (    ./src/syl.asm):00129         CCS_REF_ATOM_END        equ             ATOM_POOL_END                                   ;refs below this are ATOM refs
     0800             (    ./src/syl.asm):00130         CCS_REF_BIS_FIRST       equ             VARS_ORG                                                ;refs to built-ins
     1000             (    ./src/syl.asm):00131         CCS_REF_BIS_END         equ             VARS_END
     1400             (    ./src/syl.asm):00132         CCS_REF_CONS_FIRST      equ             CONS_POOL_ORG                                   ;refs starting here are CONS refs
     7000             (    ./src/syl.asm):00133         CCS_REF_CONS_END        equ             CONS_POOL_END                                   ;CONS refs must be < this
                      (    ./src/syl.asm):00134         
     1700             (    ./src/syl.asm):00135         CONS_POOL_COUNT         equ             CONS_POOL_SIZE/CC_SIZE                  ;total Cells in the CONS pool
     02E0             (    ./src/syl.asm):00136         GC_MARK_POOL_SIZE       equ             CONS_POOL_COUNT/8                               ;size (bytes) of the Garbage Collector Mark pool
                      (    ./src/syl.asm):00137         
                      (    ./src/syl.asm):00138         ;@@@
                      (    ./src/syl.asm):00139         ;@@@ VARIABLES (REFERENCE VIA DP REG)
                      (    ./src/syl.asm):00140         ;@@@
                      (    ./src/syl.asm):00141         
                      (    ./src/syl.asm):00142                         org             VARS_ORG
     08               (    ./src/syl.asm):00143                         setdp   VARS_ORG/256
                      (    ./src/syl.asm):00144         
0800                  (    ./src/syl.asm):00145         cons_free_list  rmb             2                                                                       ;first free CONS cell or CCS_REF_NIL
0802                  (    ./src/syl.asm):00146         cons_free_count rmb             2                                                                       ;cells in the free list
0804                  (    ./src/syl.asm):00147         cons_unalloc    rmb             2                                                                       ;start of unallocated CONS space
0806                  (    ./src/syl.asm):00148         atom_unalloc    rmb             2                                                                       ;start of unallocated ATOM space
0808                  (    ./src/syl.asm):00149         env_globals             rmb             2                                                                       ;addr/ref to global environment
                      (    ./src/syl.asm):00150         ;
080A                  (    ./src/syl.asm):00151         lex$tok$start   rmb             2                                                                       ;buf offset to start of last token
080C                  (    ./src/syl.asm):00152         read$root               rmb             2                                                                       ;saved root stack pointer
080E                  (    ./src/syl.asm):00153         sexp$par$depth  rmb             1                                                                       ;current paren depth for parsing
                      (    ./src/syl.asm):00154         ;
080F                  (    ./src/syl.asm):00155         con_buf_len             rmb             2                                                                       ;total chars in the buffer
0811                  (    ./src/syl.asm):00156         con_buf_next    rmb             2                                                                       ;offset for next input char or CON_BUF_EMPTY
0813                  (    ./src/syl.asm):00157         con_buf                 rmb             CON_BUF_SIZE                                            ;console input buffer
0863                  (    ./src/syl.asm):00158         con_loading             rmb             1                                                                       ;non-zero if we're loading from console
                      (    ./src/syl.asm):00159         ;
0864                  (    ./src/syl.asm):00160         gc_mark_pool    rmb             GC_MARK_POOL_SIZE                                       ;1 bit/cell pool of markers for GC
                      (    ./src/syl.asm):00161         ;
     04BC             (    ./src/syl.asm):00162         VARS_STACK_SIZE equ             VARS_STACK_TOP-*                                        ;available hardware stack space
                      (    ./src/syl.asm):00163         
                      (    ./src/syl.asm):00164         ;@@@
                      (    ./src/syl.asm):00165         ;@@@ CODE
                      (    ./src/syl.asm):00166         ;@@@
                      (    ./src/syl.asm):00167         
                      (    ./src/syl.asm):00168                         org             CODE_ORG
                      (    ./src/syl.asm):00169         ;
                      (    ./src/syl.asm):00170         ; $00: Cold start entry
                      (    ./src/syl.asm):00171         ;
7000                  (    ./src/syl.asm):00172         cold_start:
7000 8608             (    ./src/syl.asm):00173                                 lda             #VARS_ORG/256                                                   ;initialize Direct Page
7002 1F8B             (    ./src/syl.asm):00174                                 tfr             a,dp
7004 10CE1000         (    ./src/syl.asm):00175                                 lds             #VARS_STACK_TOP                                                 ; and stack
7008 CE1400           (    ./src/syl.asm):00176                                 ldu             #ROOT_STACK_TOP                                                 ; and context stack
700B BD7B40           (    ./src/syl.asm):00177                                 jsr             con$init                                                                ; and console
                      (    ./src/syl.asm):00178         ;
                      (    ./src/syl.asm):00179         ; Initialize pools
                      (    ./src/syl.asm):00180         ;
700E 86FF             (    ./src/syl.asm):00181                                 lda             #CON_BUF_EMPTY                                                  ;input buffer is empty
7010 9711             (    ./src/syl.asm):00182                                 sta             <con_buf_next
7012 CC1400           (    ./src/syl.asm):00183                                 ldd             #CONS_POOL_ORG                                                  ;all CONS are unallocated
7015 DD04             (    ./src/syl.asm):00184                                 std             <cons_unalloc
7017 4F               (    ./src/syl.asm):00185                                 clra                                                                                    ;free list is empty
7018 5F               (    ./src/syl.asm):00186                                 clrb
7019 DD00             (    ./src/syl.asm):00187                                 std             <cons_free_list
701B DD02             (    ./src/syl.asm):00188                                 std             <cons_free_count
                      (    ./src/syl.asm):00189         ;
701D 8E0864           (    ./src/syl.asm):00190                                 ldx             #gc_mark_pool                                                   ;ensure GC mark pool is zeroed
7020 ED81             (    ./src/syl.asm):00191         @gcpoollp       std             ,x++
7022 ED81             (    ./src/syl.asm):00192                                 std             ,x++
7024 8C0B44           (    ./src/syl.asm):00193                                 cmpx    #gc_mark_pool+GC_MARK_POOL_SIZE
7027 25F7             (    ./src/syl.asm):00194                                 blo             @gcpoollp
                      (    ./src/syl.asm):00195         ;
                      (    ./src/syl.asm):00196         ; Pre-defined ATOMs
                      (    ./src/syl.asm):00197         ;
7029 8E0000           (    ./src/syl.asm):00198                                 ldx             #ATOM_POOL_ORG                                                  ;initialize ATOM pool
702C E6897087         (    ./src/syl.asm):00199         @atomlp         ldb             default_atoms-ATOM_POOL_ORG,x
7030 E780             (    ./src/syl.asm):00200                                 stb             ,x+
7032 8C001F           (    ./src/syl.asm):00201                                 cmpx    #ATOM_POOL_ORG+end_default_atoms-default_atoms
7035 25F5             (    ./src/syl.asm):00202                                 blo             @atomlp
7037 9F06             (    ./src/syl.asm):00203                                 stx             <atom_unalloc
                      (    ./src/syl.asm):00204         ;
                      (    ./src/syl.asm):00205         ; Global environment & default bindings
                      (    ./src/syl.asm):00206         ;
7039 BD74C7           (    ./src/syl.asm):00207                                 jsr             env$alloc                                                               ;allocate the global environment
703C 9F08             (    ./src/syl.asm):00208                                 stx             <env_globals
                      (    ./src/syl.asm):00209         ;
703E 318D0064         (    ./src/syl.asm):00210                                 leay    default_bindings,pcr                                    ;list of prebound ATOMs
7042 BD74E5           (    ./src/syl.asm):00211         @bindlp         jsr             env$add$default$binding                                 ;add an entry
7045 108C71DF         (    ./src/syl.asm):00212                                 cmpy    #end_default_bindings
7049 25F7             (    ./src/syl.asm):00213                                 blo             @bindlp                                                                 ;if not done yet
                      (    ./src/syl.asm):00214         ;
704B 8D09             (    ./src/syl.asm):00215                                 bsr             bail                                                                    ;display startup banner
704D 0853796C2076312E (    ./src/syl.asm):00216                                 fcb             8,'S','y','l',' ','v',SYL_VER+'0','.',SYL_REV+'0'
     33
                      (    ./src/syl.asm):00217         ;
                      (    ./src/syl.asm):00218         ; Restart REPL
                      (    ./src/syl.asm):00219         ;
7056 3510             (    ./src/syl.asm):00220         bail:           puls    x                                                                               ;X = message
7058 10CE1000         (    ./src/syl.asm):00221                                 lds             #VARS_STACK_TOP
705C CE1400           (    ./src/syl.asm):00222                                 ldu             #ROOT_STACK_TOP
705F DC08             (    ./src/syl.asm):00223                                 ldd             <env_globals
7061 3606             (    ./src/syl.asm):00224                                 pshu    d
                      (    ./src/syl.asm):00225         ;
7063 BD7AD5           (    ./src/syl.asm):00226                                 jsr             con$msg                                                                 ;display message
7066 BD7AAB           (    ./src/syl.asm):00227                                 jsr             con$nl
7069 BD7A0F           (    ./src/syl.asm):00228                                 jsr             con$loaded                                                              ;not loading
706C BD7A55           (    ./src/syl.asm):00229                                 jsr             con$canl                                                                ;force new input line
                      (    ./src/syl.asm):00230         ;
                      (    ./src/syl.asm):00231         ; Read, Eval, Print Loop (REPL)
                      (    ./src/syl.asm):00232         ;
706F BD732B           (    ./src/syl.asm):00233         repl:           jsr             read                                                                    ;Read
7072 BD73B9           (    ./src/syl.asm):00234                                 jsr             eval                                                                    ;Eval
7075 BD757D           (    ./src/syl.asm):00235                                 jsr             print                                                                   ;Print
7078 BD7AAB           (    ./src/syl.asm):00236                                 jsr             con$nl
707B 20F2             (    ./src/syl.asm):00237                                 bra             repl
                      (    ./src/syl.asm):00238          
                      (    ./src/syl.asm):00239         ; >>> Bail w/ref display
                      (    ./src/syl.asm):00240         ; PASSED:  X = ref to be displayed; ,S = addr of string to display after
707D BD757D           (    ./src/syl.asm):00241         bail$ref:       jsr             print                                                                   ;display the item
7080 C63A             (    ./src/syl.asm):00242                                 ldb             #':'
7082 BD7AB3           (    ./src/syl.asm):00243                                 jsr             con$putc
7085 20CF             (    ./src/syl.asm):00244                                 bra             bail                                                                    ;display the message and resume
                      (    ./src/syl.asm):00245          
                      (    ./src/syl.asm):00246         ;@@@
                      (    ./src/syl.asm):00247         ;@@@ DEFAULT UNBOUND IDEMPOTENT (SELF-VALUED) ATOMS
                      (    ./src/syl.asm):00248         ;@@@ NOTE: NIL MUST BE THE FIRST SO IT'S ATOM REF IS 0
                      (    ./src/syl.asm):00249         ;@@@
                      (    ./src/syl.asm):00250         ; These ATOMs are used internally and are never bound
                      (    ./src/syl.asm):00251         ; to a specific value. ATOM_NIL *must* be the first so
                      (    ./src/syl.asm):00252         ; it's ref will be 0 which some parts of the code assume.
                      (    ./src/syl.asm):00253         ; The lower case ATOMs are used internally and can never
                      (    ./src/syl.asm):00254         ; be referenced outside of the interpreter.
                      (    ./src/syl.asm):00255         
7087                  (    ./src/syl.asm):00256         default_atoms:
     0000             (    ./src/syl.asm):00257         ATOM_NIL        equ             *-default_atoms+ATOM_POOL_ORG           ;NIL must be 0!
7087 034E494C         (    ./src/syl.asm):00258                                 fcb             3,'N','I','L'
     0004             (    ./src/syl.asm):00259         ATOM_T          equ             *-default_atoms+ATOM_POOL_ORG           ;Standard truth ATOM
708B 0154             (    ./src/syl.asm):00260                                 fcb             1,'T'
     0006             (    ./src/syl.asm):00261         ATOM_env        equ             *-default_atoms+ATOM_POOL_ORG           ;tag for environments on the U stack
708D 03656E76         (    ./src/syl.asm):00262                                 fcb             3,'e','n','v'
     000A             (    ./src/syl.asm):00263         ATOM_prg        equ             *-default_atoms+ATOM_POOL_ORG           ;tag for PROGs on the U stack
7091 03707267         (    ./src/syl.asm):00264                                 fcb             3,'p','r','g'
     000E             (    ./src/syl.asm):00265         ATOM_ret        equ             *-default_atoms+ATOM_POOL_ORG           ;tag used by RETURNs in a PROG
7095 03726574         (    ./src/syl.asm):00266                                 fcb             3,'r','e','t'
     0012             (    ./src/syl.asm):00267         ATOM_QUOTE      equ             *-default_atoms+ATOM_POOL_ORG
7099 0551554F5445     (    ./src/syl.asm):00268                                 fcb             5,'Q','U','O','T','E'
     0018             (    ./src/syl.asm):00269         ATOM_FN         equ             *-default_atoms+ATOM_POOL_ORG           ;function with eval'ed args
709F 02464E           (    ./src/syl.asm):00270                                 fcb             2,'F','N'
     001B             (    ./src/syl.asm):00271         ATOM_FNQ        equ             *-default_atoms+ATOM_POOL_ORG           ;function with uneval'ed args
70A2 03464E51         (    ./src/syl.asm):00272                                 fcb             3,'F','N','Q'
     70A6             (    ./src/syl.asm):00273         end_default_atoms equ *
     001F             (    ./src/syl.asm):00274         ATOM_LAST_IDEM  equ     end_default_atoms-default_atoms+ATOM_POOL_ORG
                      (    ./src/syl.asm):00275         
                      (    ./src/syl.asm):00276         ;@@@
                      (    ./src/syl.asm):00277         ;@@@ DEFAULT GLOBAL BINDINGS
                      (    ./src/syl.asm):00278         ;@@@
                      (    ./src/syl.asm):00279         
70A6                  (    ./src/syl.asm):00280         BIND            macro   noexpand
                      (    ./src/syl.asm):00281                                 fcb             {1}                             ;length of the name
                      (    ./src/syl.asm):00282                                 fcc             {2}                             ;the name
                      (    ./src/syl.asm):00283                                 fdb             {3}                             ;associated value
                      (    ./src/syl.asm):00284                                 endm
                      (    ./src/syl.asm):00285         
                      (    ./src/syl.asm):00286         ; Default binding (in roughly reverse order of popularity)
70A6                  (    ./src/syl.asm):00287         default_bindings:
70A6 044C4F414409AA   (    ./src/syl.asm):00288                                 BIND    4,"LOAD",BIF_LOAD
70AD 064C4F4144454409 (    ./src/syl.asm):00289                                 BIND    6,"LOADED",BIF_LOADED
     AD
70B6 0452454144097F   (    ./src/syl.asm):00290                                 BIND    4,"READ",BIF_READ
70BD 044556414C0982   (    ./src/syl.asm):00291                                 BIND    4,"EVAL",BIF_EVAL
70C4 055052494E540987 (    ./src/syl.asm):00292                                 BIND    5,"PRINT",BIF_PRINT
70CC 075052494E544C4E (    ./src/syl.asm):00293                                 BIND    7,"PRINTLN",BIF_PRINTLN
     0991
70D6 024E4C0996       (    ./src/syl.asm):00294                                 BIND    2,"NL",BIF_NL
70DB 0353594C0800     (    ./src/syl.asm):00295                                 BIND    3,"SYL",BIV_VER
70E1 03454E560804     (    ./src/syl.asm):00296                                 BIND    3,"ENV",BIV_ENV
70E7 0446524545080A   (    ./src/syl.asm):00297                                 BIND    4,"FREE",BIV_FREE
70EE 0247430A08       (    ./src/syl.asm):00298                                 BIND    2,"GC",BIQ_GC
                      (    ./src/syl.asm):00299         ;
70F3 0441544F4D0850   (    ./src/syl.asm):00300                                 BIND    4,"ATOM",BIF_ATOM
70FA 044E554C4C085F   (    ./src/syl.asm):00301                                 BIND    4,"NULL",BIF_NULL
7101 0245510863       (    ./src/syl.asm):00302                                 BIND    2,"EQ",BIF_EQ
7106 05455155414C086B (    ./src/syl.asm):00303                                 BIND    5,"EQUAL",BIF_EQUAL
710E 03414E440A35     (    ./src/syl.asm):00304                                 BIND    3,"AND",BIQ_AND
7114 024F520A4D       (    ./src/syl.asm):00305                                 BIND    2,"OR",BIQ_OR
7119 034E4F54089E     (    ./src/syl.asm):00306                                 BIND    3,"NOT",BIF_NOT
                      (    ./src/syl.asm):00307         ;
711F 034C455409D8     (    ./src/syl.asm):00308                                 BIND    3,"LET",BIQ_LET
7125 035345540999     (    ./src/syl.asm):00309                                 BIND    3,"SET",BIF_SET
712B 045345545109F0   (    ./src/syl.asm):00310                                 BIND    4,"SETQ",BIQ_SETQ
7132 0344454609C8     (    ./src/syl.asm):00311                                 BIND    3,"DEF",BIF_DEF
7138 0652504C41434108 (    ./src/syl.asm):00312                                 BIND    6,"RPLACA",BIF_RPLACA
     3C
7141 0652504C41434408 (    ./src/syl.asm):00313                                 BIND    6,"RPLACD",BIF_RPLACD
     46
                      (    ./src/syl.asm):00314         ;
714A 013D0863         (    ./src/syl.asm):00315                                 BIND    1,"=",BIF_EQ
714E 02213D08A2       (    ./src/syl.asm):00316                                 BIND    2,"!=",BIF_NE
7153 013C08AC         (    ./src/syl.asm):00317                                 BIND    1,"<",BIF_LT
7157 013E08B2         (    ./src/syl.asm):00318                                 BIND    1,">",BIF_GT
715B 023C3D08B8       (    ./src/syl.asm):00319                                 BIND    2,"<=",BIF_LE
7160 023E3D08BE       (    ./src/syl.asm):00320                                 BIND    2,">=",BIF_GE
                      (    ./src/syl.asm):00321         ;
7165 0352454D0979     (    ./src/syl.asm):00322                                 BIND    3,"REM",BIF_REM
716B 034D494E0907     (    ./src/syl.asm):00323                                 BIND    3,"MIN",BIF_MIN
7171 034D41580915     (    ./src/syl.asm):00324                                 BIND    3,"MAX",BIF_MAX
7177 017C0921         (    ./src/syl.asm):00325                                 BIND    1,"|",BIF_BIT_OR
717B 0126092D         (    ./src/syl.asm):00326                                 BIND    1,"&",BIF_BIT_AND
717F 015E0939         (    ./src/syl.asm):00327                                 BIND    1,"^",BIF_BIT_XOR
7183 012B08DA         (    ./src/syl.asm):00328                                 BIND    1,"+",BIF_ADD
7187 012D08F8         (    ./src/syl.asm):00329                                 BIND    1,"-",BIF_SUB
718B 012A0945         (    ./src/syl.asm):00330                                 BIND    1,"*",BIF_MUL
718F 012F0973         (    ./src/syl.asm):00331                                 BIND    1,"/",BIF_DIV
                      (    ./src/syl.asm):00332         ;
7193 0450524F470A60   (    ./src/syl.asm):00333                                 BIND    4,"PROG",BIQ_PROG
719A 02474F0AA0       (    ./src/syl.asm):00334                                 BIND    2,"GO",BIQ_GO
719F 0652455455524E09 (    ./src/syl.asm):00335                                 BIND    6,"RETURN",BIF_RETURN
     B0
71A8 04434F4E440A0E   (    ./src/syl.asm):00336                                 BIND    4,"COND",BIQ_COND
71AF 044C495354083B   (    ./src/syl.asm):00337                                 BIND    4,"LIST",BIF_LIST
71B6 03434152080D     (    ./src/syl.asm):00338                                 BIND    3,"CAR",BIF_CAR
71BC 034344520810     (    ./src/syl.asm):00339                                 BIND    3,"CDR",BIF_CDR
71C2 04434144520815   (    ./src/syl.asm):00340                                 BIND    4,"CADR",BIF_CADR
71C9 054341444452081B (    ./src/syl.asm):00341                                 BIND    5,"CADDR",BIF_CADDR
71D1 04434444520821   (    ./src/syl.asm):00342                                 BIND    4,"CDDR",BIF_CDDR
71D8 04434F4E530828   (    ./src/syl.asm):00343                                 BIND    4,"CONS",BIF_CONS
     71DF             (    ./src/syl.asm):00344         end_default_bindings equ *
                      (    ./src/syl.asm):00345         
                      (    ./src/syl.asm):00346         ;@@@
                      (    ./src/syl.asm):00347         ;@@@ MODULES
                      (    ./src/syl.asm):00348         ;@@@
                      (    ./src/syl.asm):00349         
                      (    ./src/syl.asm):00350                         include "lex.asm"
                      (          lex.asm):00001         ; "lex.asm" - lexer for Syl 6809 Lisp
                      (          lex.asm):00002         ; 2023-feb-16 dww  created
                      (          lex.asm):00003         
                      (          lex.asm):00004         ; Get next token.
                      (          lex.asm):00005         ; RETURNS: B = token type (TOK_LPAR, etc); X = optional associated value
71DF                  (          lex.asm):00006         lex$get$tok:
71DF BD7A18           (          lex.asm):00007                                 jsr             con$getnb                                                               ;next non-blank char
71E2 9E11             (          lex.asm):00008                                 ldx             <con_buf_next                                                   ;save token start for errors
71E4 9F0A             (          lex.asm):00009                                 stx             <lex$tok$start
                      (          lex.asm):00010         ;
                      (          lex.asm):00011         ; SIMPLE TOKENS
                      (          lex.asm):00012         ;
71E6 170090           (          lex.asm):00013                                 lbsr    lex$is$token                                                    ;is it a single char token?
71E9 2604             (          lex.asm):00014                                 bne             @neg?                                                                   ;nope
71EB 8E0000           (          lex.asm):00015                                 ldx             #ATOM_NIL                                                               ;else char is token tag
71EE 39               (          lex.asm):00016                                 rts
                      (          lex.asm):00017         ;
                      (          lex.asm):00018         ; INTEGER
                      (          lex.asm):00019         ;
71EF C12D             (          lex.asm):00020         @neg?           cmpb    #'-'
71F1 2620             (          lex.asm):00021                                 bne             @int?                                                                   ;if not negative integer
71F3 BD7A1F           (          lex.asm):00022                                 jsr             con$getc                                                                ;else get first digit
71F6 17008F           (          lex.asm):00023                                 lbsr    lex$is$digit
71F9 2707             (          lex.asm):00024                                 beq             @neg                                                                    ;if it *is* a negative number
71FB BD7A41           (          lex.asm):00025                                 jsr             con$ungetc                                                              ;else put char back
71FE C62D             (          lex.asm):00026                                 ldb             #'-'                                                                    ;and treat it as an ATOM
7200 201A             (          lex.asm):00027                                 bra             @atom
                      (          lex.asm):00028         ;
7202 1700BA           (          lex.asm):00029         @neg            lbsr    lex$parse$int                                                   ;get integer value
7205 1F10             (          lex.asm):00030                                 tfr             x,d                                                                             ;negate the int token value
7207 43               (          lex.asm):00031                                 coma
7208 53               (          lex.asm):00032                                 comb
7209 C30001           (          lex.asm):00033                                 addd    #1                                                                              ;-n = ~n + 1
720C 8A80             (          lex.asm):00034                                 ora             #CCS_TYPE_INT/256                                               ;set type as int
720E 1F01             (          lex.asm):00035                                 tfr             d,x
7210 C630             (          lex.asm):00036         @rint           ldb             #TOK_INT                                                                ;return TOK_INT
7212 39               (          lex.asm):00037                                 rts
                      (          lex.asm):00038         ;
7213 8D73             (          lex.asm):00039         @int?           bsr             lex$is$digit
7215 2605             (          lex.asm):00040                                 bne             @atom                                                                   ;if not integer then assume atom
7217 1700A5           (          lex.asm):00041                                 lbsr    lex$parse$int                                                   ;X = int value
721A 20F4             (          lex.asm):00042                                 bra             @rint                                                                   ;return TOK_INT
                      (          lex.asm):00043         ;
                      (          lex.asm):00044         ; ATOMS
                      (          lex.asm):00045         ;
721C 8D75             (          lex.asm):00046         @atom           bsr             lex$is$atom                                                             ;is it a legit ATOM char?
721E 2637             (          lex.asm):00047                                 bne             @badch                                                                  ;nope
                      (          lex.asm):00048         ;
7220 9E06             (          lex.asm):00049                                 ldx             <atom_unalloc                                                   ;copy to start of unallocated ATOM space
7222 3001             (          lex.asm):00050                                 leax    1,x                                                                             ;first byte will be length
7224 8C0800           (          lex.asm):00051         @atomlp         cmpx    #ATOM_POOL_END
7227 243C             (          lex.asm):00052                                 bhs             @full                                                                   ;if ATOM pool is full
7229 170080           (          lex.asm):00053                                 lbsr    lex$is$alpha
722C 2602             (          lex.asm):00054                                 bne             @store                                                                  ;if not alphabetic
722E C4DF             (          lex.asm):00055                                 andb    #$DF                                                                    ;else force UPPER
7230 E780             (          lex.asm):00056         @store          stb             ,x+                                                                             ;save ATOM char
7232 BD7A1F           (          lex.asm):00057                                 jsr             con$getc                                                                ;next char
7235 8D5C             (          lex.asm):00058                                 bsr             lex$is$atom
7237 27EB             (          lex.asm):00059                                 beq             @atomlp                                                                 ;if not done yet
7239 BD7A41           (          lex.asm):00060                                 jsr             con$ungetc                                                              ;uneat the delimiter
723C 1F10             (          lex.asm):00061                                 tfr             x,d                                                                             ;set the ATOM length
723E D007             (          lex.asm):00062                                 subb    <atom_unalloc+1
7240 5A               (          lex.asm):00063                                 decb
7241 9E06             (          lex.asm):00064                                 ldx             <atom_unalloc
7243 E784             (          lex.asm):00065                                 stb             ,x
                      (          lex.asm):00066         ;
7245 BD7301           (          lex.asm):00067                                 jsr             lex$find$atom                                                   ;is it already in the pool?
7248 270A             (          lex.asm):00068                                 beq             @ret                                                                    ;if so (X = addr/ref)
724A 3410             (          lex.asm):00069                                 pshs    x                                                                               ;else add at the end
724C E684             (          lex.asm):00070                                 ldb             ,x
724E 5C               (          lex.asm):00071                                 incb
724F 3A               (          lex.asm):00072                                 abx
7250 9F06             (          lex.asm):00073                                 stx             <atom_unalloc
7252 3510             (          lex.asm):00074                                 puls    x                                                                               ;X = addr/ref
7254 C623             (          lex.asm):00075         @ret            ldb             #TOK_ATOM                                                               ;return TOK_ATOM, X = ref
7256 39               (          lex.asm):00076                                 rts
                      (          lex.asm):00077         ;
7257 BD7056           (          lex.asm):00078         @badch          jsr             bail
725A 0A42616420436861 (          lex.asm):00079                                 fcb             10,'B','a','d',' ','C','h','a','r','!',BEL
     722107
                      (          lex.asm):00080         ;
7265 BD7056           (          lex.asm):00081         @full           jsr             bail
7268 1041746F6D20706F (          lex.asm):00082                                 fcb             16,'A','t','o','m',' ','p','o','o','l',' ','f','u','l','l','!',BEL
     6F6C2066756C6C21
     07
                      (          lex.asm):00083         
                      (          lex.asm):00084         ; >>> Is char a legit (single-char) token?
                      (          lex.asm):00085         ; PASSED:  B = input char
                      (          lex.asm):00086         ; RETURNS: EQ if it is a legit token else NE
7279                  (          lex.asm):00087         lex$is$token:
7279 C128             (          lex.asm):00088                                 cmpb    #'('
727B 270A             (          lex.asm):00089                                 beq             @ret                                                                    ;return TOK_LPAR
727D C129             (          lex.asm):00090                                 cmpb    #')'
727F 2706             (          lex.asm):00091                                 beq             @ret                                                                    ;return TOK_RPAR
7281 C12E             (          lex.asm):00092                                 cmpb    #'.'
7283 2702             (          lex.asm):00093                                 beq             @ret                                                                    ;return TOK_DOT
7285 C127             (          lex.asm):00094                                 cmpb    #SQUOT
7287 39               (          lex.asm):00095         @ret            rts
                      (          lex.asm):00096         
                      (          lex.asm):00097         ; >>> Is char an integer digit?
                      (          lex.asm):00098         ; PASSED:  B = input char
                      (          lex.asm):00099         ; RETURNS: EQ if it is a digit else NE
7288                  (          lex.asm):00100         lex$is$digit:
7288 C130             (          lex.asm):00101                                 cmpb    #'0'
728A 2506             (          lex.asm):00102                                 blo             @ret                                                                    ;not a digit
728C C139             (          lex.asm):00103                                 cmpb    #'9'
728E 2202             (          lex.asm):00104                                 bhi             @ret                                                                    ;ditto
7290 1A04             (          lex.asm):00105                                 orcc    #$04                                                                    ;else return EQ
7292 39               (          lex.asm):00106         @ret            rts
                      (          lex.asm):00107         
                      (          lex.asm):00108         ; >>> Is char a valid ATOM char?
                      (          lex.asm):00109         ; PASSED:  B = input char
                      (          lex.asm):00110         ; RETURNS: EQ if it is a valid ATOM char else NE
7293                  (          lex.asm):00111         lex$is$atom:
7293 8D17             (          lex.asm):00112                                 bsr             lex$is$alpha
7295 2714             (          lex.asm):00113                                 beq             @ret                                                                    ;yep, it's a letter
7297 8DEF             (          lex.asm):00114                                 bsr             lex$is$digit
7299 2710             (          lex.asm):00115                                 beq             @ret                                                                    ;yep, it's a digit
729B C121             (          lex.asm):00116                                 cmpb    #SPACE+1
729D 250C             (          lex.asm):00117                                 blo             @ret                                                                    ;nope, it's whitespace
729F 8DD8             (          lex.asm):00118                                 bsr             lex$is$token
72A1 3402             (          lex.asm):00119                                 pshs    a
72A3 1FA8             (          lex.asm):00120                                 tfr             cc,a                                                                    ;it is is it's not a token
72A5 8804             (          lex.asm):00121                                 eora    #$04                                                                    ;(flip EQ->NE, NE->EQ)
72A7 1F8A             (          lex.asm):00122                                 tfr             a,cc
72A9 3502             (          lex.asm):00123                                 puls    a
72AB 39               (          lex.asm):00124         @ret            rts
                      (          lex.asm):00125         
                      (          lex.asm):00126         ; >>> Is char an alphabetic (letter)?
                      (          lex.asm):00127         ; PASSED:  B = input char
                      (          lex.asm):00128         ; RETURNS: EQ if it is a valid alpha char else NE
72AC                  (          lex.asm):00129         lex$is$alpha:
72AC C141             (          lex.asm):00130                                 cmpb    #'A'
72AE 250E             (          lex.asm):00131                                 blo             @ret                                                                    ;nope
72B0 C15A             (          lex.asm):00132                                 cmpb    #'Z'
72B2 2308             (          lex.asm):00133                                 bls             @yep                                                                    ;yep
72B4 C161             (          lex.asm):00134                                 cmpb    #'a'
72B6 2506             (          lex.asm):00135                                 blo             @ret                                                                    ;nope
72B8 C17A             (          lex.asm):00136                                 cmpb    #'z'
72BA 2202             (          lex.asm):00137                                 bhi             @ret                                                                    ;nope
72BC 1A04             (          lex.asm):00138         @yep            orcc    #$04                                                                    ;yep, return EQ
72BE 39               (          lex.asm):00139         @ret            rts
                      (          lex.asm):00140         
                      (          lex.asm):00141         ; >>> Parse integer cell value
                      (          lex.asm):00142         ; PASSED:  B = first char of integer (assumed valid)
                      (          lex.asm):00143         ; RETURNS: X = integer cell value
                      (          lex.asm):00144         ; NOTE: bails on invalid integer value (illegal char or out of range)
72BF                  (          lex.asm):00145         lex$parse$int:
72BF C030             (          lex.asm):00146                                 subb    #'0'                                                                    ;X = first digit value
72C1 4F               (          lex.asm):00147                                 clra
72C2 1F01             (          lex.asm):00148                                 tfr             d,x
                      (          lex.asm):00149         ;
72C4 BD7A1F           (          lex.asm):00150         @lp                     jsr             con$getc                                                                ;next char
72C7 8DBF             (          lex.asm):00151                                 bsr             lex$is$digit
72C9 2616             (          lex.asm):00152                                 bne             @end                                                                    ;if end of integer
72CB C030             (          lex.asm):00153                                 subb    #'0'                                                                    ;X = X*10 + digit
72CD 3404             (          lex.asm):00154                                 pshs    b
72CF 1F10             (          lex.asm):00155                                 tfr             x,d
72D1 308B             (          lex.asm):00156                                 leax    d,x                                                                             ;X *= 2
72D3 58               (          lex.asm):00157                                 aslb
72D4 49               (          lex.asm):00158                                 rola
72D5 58               (          lex.asm):00159                                 aslb
72D6 49               (          lex.asm):00160                                 rola
72D7 308B             (          lex.asm):00161                                 leax    d,x                                                                             ;X *= 6
72D9 308B             (          lex.asm):00162                                 leax    d,x                                                                             ;X *= 10
72DB 3504             (          lex.asm):00163                                 puls    b
72DD 3085             (          lex.asm):00164                                 leax    b,x
72DF 20E3             (          lex.asm):00165                                 bra             @lp
                      (          lex.asm):00166         ;
72E1 8DC9             (          lex.asm):00167         @end            bsr             lex$is$alpha                                                    ;can't end on letter
72E3 270F             (          lex.asm):00168                                 beq             @bad
72E5 BD7A41           (          lex.asm):00169                                 jsr             con$ungetc                                                              ;put delim back
                      (          lex.asm):00170         ;
72E8 8C3FFF           (          lex.asm):00171                                 cmpx    #CCS_INT_MAX
72EB 2E07             (          lex.asm):00172                                 bgt             @bad
                      (          lex.asm):00173         ;
72ED 1F10             (          lex.asm):00174                                 tfr             x,d                                                                             ;convert to slot INT
72EF 8A80             (          lex.asm):00175                                 ora             #CCS_TYPE_INT/256
72F1 1F01             (          lex.asm):00176                                 tfr             d,x
72F3 39               (          lex.asm):00177                                 rts
                      (          lex.asm):00178         ;
72F4 BD7056           (          lex.asm):00179         @bad            jsr             bail
72F7 0942616420496E74 (          lex.asm):00180                                 fcb             9,'B','a','d',' ','I','n','t','!',BEL
     2107
                      (          lex.asm):00181         
                      (          lex.asm):00182         ; >>> Find ATOM ref in the pool
                      (          lex.asm):00183         ; PASSED:  X = addr of ATOM name (length byte first)
                      (          lex.asm):00184         ; RETURNS: EQ, X = ATOM ref/addr else NE and X unchanged
                      (          lex.asm):00185         ; NOTE: Was going to use a hash table for speed but I don't think the complexity
                      (          lex.asm):00186         ; is worth it. A straight linear search should be fast enough since we're only
                      (          lex.asm):00187         ; ever doing ATOM searches from interactive input so a few ms isn't going to matter.
                      (          lex.asm):00188         ; Also, the compare loop assumes ATOMs are < 128 chars long which is safe as
                      (          lex.asm):00189         ; long as the input buffer length is also < 128 chars.
7301                  (          lex.asm):00190         lex$find$atom:
7301 3426             (          lex.asm):00191                                 pshs    y,d
7303 108E0000         (          lex.asm):00192                                 ldy             #ATOM_POOL_ORG                                                  ;Y = next ATOM name in pool
                      (          lex.asm):00193         ;
7307 109C06           (          lex.asm):00194         @atomlp         cmpy    <atom_unalloc
730A 241B             (          lex.asm):00195                                 bhs             @nope                                                                   ;if ATOM not found
                      (          lex.asm):00196         ;
730C 3430             (          lex.asm):00197                                 pshs    y,x                                                                             ;see if names match
730E A6A4             (          lex.asm):00198                                 lda             ,y                                                                              ;A = pool name len = compare count - 1
7310 E680             (          lex.asm):00199         @namelp         ldb             ,x+
7312 E1A0             (          lex.asm):00200                                 cmpb    ,y+
7314 2609             (          lex.asm):00201                                 bne             @next                                                                   ;if they don't match
7316 4A               (          lex.asm):00202                                 deca
7317 2AF7             (          lex.asm):00203                                 bpl             @namelp                                                                 ;if not done yet
                      (          lex.asm):00204         ;
7319 3516             (          lex.asm):00205                                 puls    d,x                                                                             ;X = pool ATOM addr/ref
731B 4F               (          lex.asm):00206                                 clra                                                                                    ;return EQ
731C 3526             (          lex.asm):00207         @done           puls    d,y
731E 39               (          lex.asm):00208                                 rts
                      (          lex.asm):00209         ;
731F 31A6             (          lex.asm):00210         @next           leay    a,y                                                                             ;skip to next pool ATOM
7321 3510             (          lex.asm):00211                                 puls    x                                                                               ;X = target name again
7323 3262             (          lex.asm):00212                                 leas    2,s                                                                             ;clean stack
7325 20E0             (          lex.asm):00213                                 bra             @atomlp                                                                 ;and try next
                      (          lex.asm):00214         ;
7327 1CFB             (          lex.asm):00215         @nope           andcc   #~$04                                                                   ;return NE
7329 20F1             (          lex.asm):00216                                 bra             @done
                      (    ./src/syl.asm):00351                         include "read.asm"
                      (         read.asm):00001         ; "read.asm" - Read S-Expression support for Syl LISP
                      (         read.asm):00002         ; 2023-feb-20 dww  created
                      (         read.asm):00003         
                      (         read.asm):00004         ; >>> Read the next S-Expression from the console
                      (         read.asm):00005         ; RETURNS: X = addr/ref to the s-expression
                      (         read.asm):00006         ; NOTE: It's won't be protected from following GCs unless you
                      (         read.asm):00007         ; push it on the root stack.
732B                  (         read.asm):00008         read:
732B DF0C             (         read.asm):00009                                 stu             <read$root                                                              ;in case we fail
732D 0F0E             (         read.asm):00010                                 clr             <sexp$par$depth                                                 ;no parens yet
                      (         read.asm):00011         ;
732F BD71DF           (         read.asm):00012         @sexpr          jsr             lex$get$tok                                                             ;next token
7332 C130             (         read.asm):00013         @sexpr2         cmpb    #TOK_INT
7334 2723             (         read.asm):00014                                 beq             @done                                                                   ;we're done if it's an integer
7336 C123             (         read.asm):00015                                 cmpb    #TOK_ATOM
7338 271F             (         read.asm):00016                                 beq             @done                                                                   ;ditto for ATOM
733A C128             (         read.asm):00017                                 cmpb    #TOK_LPAR
733C 271C             (         read.asm):00018                                 beq             @cons                                                                   ;get parened CONS
733E C127             (         read.asm):00019                                 cmpb    #TOK_QUOTE
7340 2669             (         read.asm):00020                                 bne             @serr                                                                   ;if not quoted expr
                      (         read.asm):00021         ;
                      (         read.asm):00022         ; 'expr -> (QUOTE expr)
                      (         read.asm):00023         ;
7342 8DEB             (         read.asm):00024         @quote          bsr             @sexpr                                                                  ;X = expression to quote
7344 3610             (         read.asm):00025                                 pshu    x                                                                               ;save & protect it
7346 BD7609           (         read.asm):00026                                 jsr             cons$alloc                                                              ;make it into a list
7349 3706             (         read.asm):00027                                 pulu    d
734B ED84             (         read.asm):00028                                 std             CC_CAR_OFF,x                                                    ;CDR is inited to NIL
734D 3610             (         read.asm):00029                                 pshu    x                                                                               ;save/protect it
734F CC0012           (         read.asm):00030                                 ldd             #ATOM_QUOTE                                                             ;allocate quote ref
7352 BD7600           (         read.asm):00031                                 jsr             cons$alloc$tag
7355 3706             (         read.asm):00032                                 pulu    d
7357 ED02             (         read.asm):00033                                 std             CC_CDR_OFF,x                                                    ;set ref to expr list
7359 39               (         read.asm):00034         @done           rts
                      (         read.asm):00035         ;
                      (         read.asm):00036         ; CONS (dotted pair or list)
                      (         read.asm):00037         ;
735A BD71DF           (         read.asm):00038         @cons           jsr             lex$get$tok                                                             ;check for empty list
735D C129             (         read.asm):00039                                 cmpb    #TOK_RPAR
735F 2731             (         read.asm):00040                                 beq             @empty                                                                  ;() -> NIL
                      (         read.asm):00041         ;
7361 0C0E             (         read.asm):00042                                 inc             <sexp$par$depth                                                 ;non-empty list/pair, bump paren level
7363 3414             (         read.asm):00043                                 pshs    x,b                                                                             ;allocate root cell
7365 BD7609           (         read.asm):00044                                 jsr             cons$alloc
7368 1F10             (         read.asm):00045                                 tfr             x,d                                                                             ;2,u = root, 0,u = end of list
736A 3616             (         read.asm):00046                                 pshu    x,d
736C 3514             (         read.asm):00047                                 puls    b,x
                      (         read.asm):00048         ;
736E 8DC2             (         read.asm):00049         @conslp         bsr             @sexpr2                                                                 ;get next item
7370 1F10             (         read.asm):00050                                 tfr             x,d
7372 AEC4             (         read.asm):00051                                 ldx             ,u
7374 ED84             (         read.asm):00052                                 std             CC_CAR_OFF,x                                                    ;set as car op last item
                      (         read.asm):00053         ;
7376 BD71DF           (         read.asm):00054                                 jsr             lex$get$tok                                                             ;more to come?
7379 C129             (         read.asm):00055                                 cmpb    #TOK_RPAR
737B 2729             (         read.asm):00056                                 beq             @consend                                                                ;nope
737D C12E             (         read.asm):00057                                 cmpb    #TOK_DOT
737F 2716             (         read.asm):00058                                 beq             @dotted                                                                 ;yep, need cdr of dotted pair
                      (         read.asm):00059         ;
7381 3414             (         read.asm):00060                                 pshs    x,b                                                                             ;allocate new last cell
7383 BD7609           (         read.asm):00061                                 jsr             cons$alloc
7386 1F10             (         read.asm):00062                                 tfr             x,d                                                                             ;link it to previous last
7388 AEC4             (         read.asm):00063                                 ldx             ,u
738A ED02             (         read.asm):00064                                 std             CC_CDR_OFF,x
738C EDC4             (         read.asm):00065                                 std             ,u
738E 3514             (         read.asm):00066                                 puls    b,x
7390 20DC             (         read.asm):00067                                 bra             @conslp                                                                 ;and get next item
                      (         read.asm):00068         ;
7392 8E0000           (         read.asm):00069         @empty          ldx             #ATOM_NIL                                                               ;return empty list
7395 20C2             (         read.asm):00070                                 bra             @done
                      (         read.asm):00071         ;
7397 8D96             (         read.asm):00072         @dotted         bsr             @sexpr                                                                  ;get cdr for current cell
7399 1F10             (         read.asm):00073                                 tfr             x,d
739B AEC4             (         read.asm):00074                                 ldx             ,u
739D ED02             (         read.asm):00075                                 std             CC_CDR_OFF,x
                      (         read.asm):00076         ;
739F BD71DF           (         read.asm):00077                                 jsr             lex$get$tok                                                             ;better be closing paren
73A2 C129             (         read.asm):00078                                 cmpb    #TOK_RPAR
73A4 2605             (         read.asm):00079                                 bne             @serr                                                                   ;else bail
                      (         read.asm):00080         ;
73A6 3716             (         read.asm):00081         @consend        pulu    d,x                                                                             ;X = root of list
73A8 0A0E             (         read.asm):00082                                 dec             <sexp$par$depth                                                 ;up a paren level
73AA 39               (         read.asm):00083                                 rts
                      (         read.asm):00084         ;
73AB DE0C             (         read.asm):00085         @serr           ldu             <read$root                                                              ;restore original root
73AD BD7056           (         read.asm):00086                                 jsr             bail
73B0 0853796E74617821 (         read.asm):00087                                 fcb             8,'S','y','n','t','a','x','!',BEL
     07
                      (    ./src/syl.asm):00352                         include "eval.asm"
                      (         eval.asm):00001         ; "eval.asm" - Evaluate an S-Expression for Syl
                      (         eval.asm):00002         ; 2023-feb-20 dww  created
                      (         eval.asm):00003         
                      (         eval.asm):00004         ; >>> Evaluate an S-Expression
                      (         eval.asm):00005         ; PASSED:  X = root of the S-Expression
                      (         eval.asm):00006         ; RETURNS: X = root of the result
                      (         eval.asm):00007         ; NOTE: This uses the known order of ref types (ATOMs, Built-Ins, CONS, etc)
                      (         eval.asm):00008         ; for more efficient dispatch so if that changes this must too.
73B9                  (         eval.asm):00009         eval:
73B9 8C0800           (         eval.asm):00010                                 cmpx    #CCS_REF_ATOM_END
73BC 250B             (         eval.asm):00011                                 blo             eval$atom                                               ;eval an ATOM
73BE 8C1000           (         eval.asm):00012                                 cmpx    #CCS_REF_BIS_END
73C1 2510             (         eval.asm):00013                                 blo             eval$bis                                                ;eval a built-in
73C3 8C7000           (         eval.asm):00014                                 cmpx    #CCS_REF_CONS_END
73C6 251B             (         eval.asm):00015                                 blo             eval$cons                                               ;eval a CONS cell
73C8 39               (         eval.asm):00016         @ret            rts                                                                             ;else assume value is self (e.g. Ints)
                      (         eval.asm):00017         ;
                      (         eval.asm):00018         ; Evaluate an ATOM
                      (         eval.asm):00019         ;
73C9 8C001F           (         eval.asm):00020         eval$atom:      cmpx    #ATOM_LAST_IDEM
73CC 25FA             (         eval.asm):00021                                 blo             @ret                                                    ;idempotent always evaluate to itself
73CE BD7541           (         eval.asm):00022                                 jsr             env$get$atom$binding
73D1 AE02             (         eval.asm):00023                                 ldx             CC_CDR_OFF,x                                    ;X = bound value
                      (         eval.asm):00024                 ; fall through into (to eval BIVs) ...
                      (         eval.asm):00025         ;
                      (         eval.asm):00026         ; Evaluate a naked built-in ref if it's a BIV
                      (         eval.asm):00027         ;
73D3 8C0800           (         eval.asm):00028         eval$bis:       cmpx    #CCS_REF_BIV_FIRST
73D6 25F0             (         eval.asm):00029                                 blo             @ret                                                    ;return self if not a built-in value
73D8 8C080D           (         eval.asm):00030                                 cmpx    #CCS_REF_BIV_END
73DB 24EB             (         eval.asm):00031                                 bhs             @ret                                                    ;ditto
                      (         eval.asm):00032         ;
73DD 30896EE2         (         eval.asm):00033         @biv            leax    bis$base-CCS_REF_BIV_FIRST,x    ;X = address of BIV routine
73E1 6E84             (         eval.asm):00034                                 jmp             ,x                                                              ;invoke it and return
                      (         eval.asm):00035         ;
                      (         eval.asm):00036         ; Evaluate a CONS
                      (         eval.asm):00037         ;
73E3 3610             (         eval.asm):00038         eval$cons:      pshu    x                                                               ;protect expr
73E5 AE84             (         eval.asm):00039                                 ldx             CC_CAR_OFF,x
73E7 8DD0             (         eval.asm):00040                                 bsr             eval                                                    ;X = (EVAL (CAR e)) = possible invocation target
                      (         eval.asm):00041         ;
73E9 8C0012           (         eval.asm):00042                                 cmpx    #ATOM_QUOTE
73EC 2750             (         eval.asm):00043                                 beq             @quote                                                  ;if it's a quoted expr
73EE 8C080D           (         eval.asm):00044                                 cmpx    #CCS_REF_BIF_FIRST
73F1 2514             (         eval.asm):00045                                 blo             @self                                                   ;if it's an ATOM or BIV
73F3 8C09D8           (         eval.asm):00046                                 cmpx    #CCS_REF_BIF_END
73F6 254C             (         eval.asm):00047                                 blo             @bif                                                    ;if it's a built-in function
73F8 8C0ACB           (         eval.asm):00048                                 cmpx    #CCS_REF_BIQ_END
73FB 2554             (         eval.asm):00049                                 blo             @biq                                                    ;if it's a built-in quoted function
73FD 8C1400           (         eval.asm):00050                                 cmpx    #CCS_REF_CONS_FIRST
7400 2505             (         eval.asm):00051                                 blo             @self                                                   ;if it's not a CONS
7402 8C7000           (         eval.asm):00052                                 cmpx    #CCS_REF_CONS_END
7405 2503             (         eval.asm):00053                                 blo             @cons                                                   ;if it is a CONS
                      (         eval.asm):00054         ;
7407 3710             (         eval.asm):00055         @self           pulu    x                                                               ;value is original CONS (?)
7409 39               (         eval.asm):00056                                 rts
                      (         eval.asm):00057         ;
                      (         eval.asm):00058         ; Possible invocation target is a CONS
                      (         eval.asm):00059         ; X = invocation target; ,U = original CONS expression
                      (         eval.asm):00060         ;
740A EC84             (         eval.asm):00061         @cons           ldd             CC_CAR_OFF,x
740C 10830018         (         eval.asm):00062                                 cmpd    #ATOM_FN
7410 2722             (         eval.asm):00063                                 beq             @fn                                                             ;if it's a function invocation
7412 1083001B         (         eval.asm):00064                                 cmpd    #ATOM_FNQ
7416 26EF             (         eval.asm):00065                                 bne             @self                                                   ;if it's not a quoted function invocation
                      (         eval.asm):00066         ;
                      (         eval.asm):00067         ; Invoking an FNQ function: ((FNQ (arg-names) (body)) arg-values)
                      (         eval.asm):00068         ; X = invocation target; ,U = original CONS expression
                      (         eval.asm):00069         ;
7418 3610             (         eval.asm):00070         @fnq            pshu    x                                                               ;protect FNQ definition
741A AE42             (         eval.asm):00071                                 ldx             2,u
741C AE02             (         eval.asm):00072                                 ldx             CC_CDR_OFF,x                                    ;X = arg-values
                      (         eval.asm):00073         ;
741E 10AEC4           (         eval.asm):00074         @apply          ldy             ,u                                                              ;Y = (FNQ ...)
7421 10AEB802         (         eval.asm):00075                                 ldy             [CC_CDR_OFF,y]                                  ;Y = (CADR (FNQ ...)) = arg-names
7425 8D70             (         eval.asm):00076                                 bsr             eval$apply$args                                 ;push ENV with assigned arg values to Y
                      (         eval.asm):00077         ;
7427 AE42             (         eval.asm):00078                                 ldx             2,u                                                             ;X = (FNQ ...)
7429 AE02             (         eval.asm):00079                                 ldx             CC_CDR_OFF,x
742B AE9802           (         eval.asm):00080                                 ldx             [CC_CDR_OFF,x]                                  ;X = (CADDR (FNQ)) = function body
742E BD73B9           (         eval.asm):00081                                 jsr             eval                                                    ;evaluate it
                      (         eval.asm):00082         ;
7431 3346             (         eval.asm):00083                                 leau    6,u                                                             ;pop ENV, clean up the stack
7433 39               (         eval.asm):00084                                 rts
                      (         eval.asm):00085         ;
                      (         eval.asm):00086         ; Invoking an FN function: ((FNQ (arg-names) (body)) arg-values)
                      (         eval.asm):00087         ; X = invocation target; ,U = original CONS expression
                      (         eval.asm):00088         ;
7434 3610             (         eval.asm):00089         @fn                     pshu    x                                                               ;protect FN definition
7436 AE42             (         eval.asm):00090                                 ldx             2,u
7438 AE02             (         eval.asm):00091                                 ldx             CC_CDR_OFF,x                                    ;X = arg-values
743A 8D20             (         eval.asm):00092                                 bsr             eval$list                                               ;X = (EVAL arg-values)
743C 20E0             (         eval.asm):00093                                 bra             @apply                                                  ;finish like FNQ
                      (         eval.asm):00094         ;
                      (         eval.asm):00095         ; (QUOTE s) - return unevaluated arg
                      (         eval.asm):00096         ;
743E 3710             (         eval.asm):00097         @quote          pulu    x                                                               ;X = original CONS
7440 AE9802           (         eval.asm):00098                                 ldx             [CC_CDR_OFF,x]                                  ;return unevalated arg
7443 39               (         eval.asm):00099                                 rts
                      (         eval.asm):00100         ;
                      (         eval.asm):00101         ; (BIF args) - built-in function with evaluated args
                      (         eval.asm):00102         ;
7444 30896EE2         (         eval.asm):00103         @bif            leax    bis$base-CCS_REF_BIV_FIRST,x    ;X = address of BIF routine
7448 3410             (         eval.asm):00104                                 pshs    x
744A 3710             (         eval.asm):00105                                 pulu    x                                                               ;X = original CONS
744C AE02             (         eval.asm):00106                                 ldx             CC_CDR_OFF,x                                    ;X = arg list
744E 8D0C             (         eval.asm):00107                                 bsr             eval$list                                               ;X = evaluated arg list
7450 39               (         eval.asm):00108                                 rts                                                                             ;off to the built-in
                      (         eval.asm):00109         ;
                      (         eval.asm):00110         ; (BIQ args) - built-in function with unevaluated args
                      (         eval.asm):00111         ;
7451 30896EE2         (         eval.asm):00112         @biq            leax    bis$base-CCS_REF_BIV_FIRST,x    ;X = address of BIQ routine
7455 3410             (         eval.asm):00113                                 pshs    x
7457 3710             (         eval.asm):00114                                 pulu    x                                                               ;X = original CONS
7459 AE02             (         eval.asm):00115                                 ldx             CC_CDR_OFF,x                                    ;X = unevaluated arg list
745B 39               (         eval.asm):00116                                 rts                                                                             ;off to the built-in
                      (         eval.asm):00117         
                      (         eval.asm):00118         ; >>> Evaluate a list of items
                      (         eval.asm):00119         ; PASSED:  X = ref to first CONS in list
                      (         eval.asm):00120         ; RETURNS: X = ref to new list with evaluated items
745C                  (         eval.asm):00121         eval$list:
745C CC73B9           (         eval.asm):00122                                 ldd             #eval                                                   ;D = subr to apply
                      (         eval.asm):00123                 ; fall through into ...
                      (         eval.asm):00124         ; >>> Generate a new list by calling a subr for each item of an existing list.
                      (         eval.asm):00125         ; PASSED:  X = ref to an existing list, D = addr of one arg subroutine to call on each item.
                      (         eval.asm):00126         ; RETURNS: X = ref to a new list with the results of the calls.
745F                  (         eval.asm):00127         eval$maplist:
745F 8C0000           (         eval.asm):00128                                 cmpx    #ATOM_NIL
7462 2732             (         eval.asm):00129                                 beq             @ret                                                    ;NIL -> NIL
7464 3406             (         eval.asm):00130                                 pshs    d                                                               ;,s = subroutine to call
                      (         eval.asm):00131         ;
7466 3610             (         eval.asm):00132                                 pshu    x                                                               ;4,u = current source list item
7468 BD7609           (         eval.asm):00133                                 jsr             cons$alloc
746B 1F10             (         eval.asm):00134                                 tfr             x,d
746D 3616             (         eval.asm):00135                                 pshu    x,d                                                             ;2,u = root of dest list; ,u = current dest item
                      (         eval.asm):00136         ;
746F AE44             (         eval.asm):00137         @maplp          ldx             4,u
7471 AE84             (         eval.asm):00138                                 ldx             CC_CAR_OFF,x                                    ;X = current item
7473 ADF4             (         eval.asm):00139                                 jsr             [,s]                                                    ;call the function
7475 1F10             (         eval.asm):00140                                 tfr             x,d
7477 AEC4             (         eval.asm):00141                                 ldx             ,u                                                              ;store result in dest list
7479 ED84             (         eval.asm):00142                                 std             CC_CAR_OFF,x
                      (         eval.asm):00143         ;
747B AE44             (         eval.asm):00144                                 ldx             4,u                                                             ;advance to next source item
747D AE02             (         eval.asm):00145                                 ldx             CC_CDR_OFF,x
747F 270F             (         eval.asm):00146                                 beq             @mapend                                                 ;if hit end of list
7481 AF44             (         eval.asm):00147                                 stx             4,u                                                             ;update current item
7483 BD7609           (         eval.asm):00148                                 jsr             cons$alloc                                              ;allocate another dest item
7486 1F10             (         eval.asm):00149                                 tfr             x,d
7488 AEC4             (         eval.asm):00150                                 ldx             ,u
748A ED02             (         eval.asm):00151                                 std             CC_CDR_OFF,x
748C EDC4             (         eval.asm):00152                                 std             ,u
748E 20DF             (         eval.asm):00153                                 bra             @maplp                                                  ;handle next item
                      (         eval.asm):00154         ;
7490 AE42             (         eval.asm):00155         @mapend         ldx             2,u                                                             ;X = new list
7492 3346             (         eval.asm):00156                                 leau    6,u                                                             ;clean up stacks
7494 3262             (         eval.asm):00157                                 leas    2,s
7496 39               (         eval.asm):00158         @ret            rts
                      (         eval.asm):00159         
                      (         eval.asm):00160         ; >>> Create an ENV with actual args values assigned to arg names
                      (         eval.asm):00161         ; PASSED:  Y = list of names, X = list of values (may be NIL)
                      (         eval.asm):00162         ; Pushes new ENV with assigned values to U.
7497                  (         eval.asm):00163         eval$apply$args:
7497 3630             (         eval.asm):00164                                 pshu    y,x                                                             ;2,U = values, 4,U = names
7499 BD74C7           (         eval.asm):00165                                 jsr             env$alloc
749C 3610             (         eval.asm):00166                                 pshu    x                                                               ;,U = env
                      (         eval.asm):00167         ;
749E AE44             (         eval.asm):00168         @lp                     ldx             4,u                                                             ;X = next item in names list
74A0 271E             (         eval.asm):00169                                 beq             @done                                                   ;if no more
74A2 EC84             (         eval.asm):00170                                 ldd             CC_CAR_OFF,x                                    ;D = name ATOM
74A4 AE02             (         eval.asm):00171                                 ldx             CC_CDR_OFF,x
74A6 AF44             (         eval.asm):00172                                 stx             4,u
                      (         eval.asm):00173         ;
74A8 AE42             (         eval.asm):00174                                 ldx             2,u                                                             ;X = next item in values list
74AA 2708             (         eval.asm):00175                                 beq             @add                                                    ;use NIL if none left
74AC 10AE02           (         eval.asm):00176                                 ldy             CC_CDR_OFF,x
74AF 10AF42           (         eval.asm):00177                                 sty             2,u
74B2 AE84             (         eval.asm):00178                                 ldx             CC_CAR_OFF,x                                    ;X = value
                      (         eval.asm):00179         ;
74B4 BD74CD           (         eval.asm):00180         @add            jsr             env$alloc$binding                               ;X = binding entry
74B7 1F10             (         eval.asm):00181                                 tfr             x,d
74B9 AEC4             (         eval.asm):00182                                 ldx             ,u                                                              ;X = ENV head
74BB BD74FE           (         eval.asm):00183                                 jsr             env$add$binding                                 ;add binding to ENV
74BE 20DE             (         eval.asm):00184                                 bra             @lp
                      (         eval.asm):00185         ;
74C0 3706             (         eval.asm):00186         @done           pulu    d                                                               ;clean up ref stack
74C2 3342             (         eval.asm):00187                                 leau    2,u
74C4 EDC4             (         eval.asm):00188                                 std             ,u                                                              ;but leave ENV on top
74C6 39               (         eval.asm):00189                                 rts
                      (    ./src/syl.asm):00353                         include "env.asm"
                      (          env.asm):00001         ; "env.asm" - Environment utilities for Syl
                      (          env.asm):00002         ; 2023-feb-25 dww  created
                      (          env.asm):00003         
                      (          env.asm):00004         ; >>> Allocate an empty environment
                      (          env.asm):00005         ; RETURNS: X = addr/ref to newly allocated, empty environment list
                      (          env.asm):00006         ; NOTE: On return the environment will NOT be protected from future
                      (          env.asm):00007         ; garbage collections so make sure you push it to the ROOT stack
                      (          env.asm):00008         ; before the next cycle or it will be freed.
74C7                  (          env.asm):00009         env$alloc:
74C7 CC0006           (          env.asm):00010                                 ldd             #ATOM_env
74CA 7E7600           (          env.asm):00011                                 jmp             cons$alloc$tag
                      (          env.asm):00012         
                      (          env.asm):00013         ; >>> Allocate an ATOM binding entry for an environment
                      (          env.asm):00014         ; PASSED:  D = ATOM reference, X = value to bind to it
                      (          env.asm):00015         ; RETURNS: X = ref to newly allocate entry
                      (          env.asm):00016         ; NOTE: returned ref is NOT protected from future GCs.
74CD                  (          env.asm):00017         env$alloc$binding:
74CD 3436             (          env.asm):00018                                 pshs    y,x,d
74CF BD7609           (          env.asm):00019                                 jsr             cons$alloc                                                      ;allocate ATOM binding cell
74D2 3526             (          env.asm):00020                                 puls    d,y
74D4 ED84             (          env.asm):00021                                 std             CC_CAR_OFF,x                                            ;CAR is ATOM
74D6 10AF02           (          env.asm):00022                                 sty             CC_CDR_OFF,x                                            ;CDR is bound value
74D9 3610             (          env.asm):00023                                 pshu    x                                                                       ;protect it
74DB BD7609           (          env.asm):00024                                 jsr             cons$alloc                                                      ;allocate env list entry
74DE 3706             (          env.asm):00025                                 pulu    d
74E0 ED84             (          env.asm):00026                                 std             CC_CAR_OFF,x                                            ;CAR points to binding
74E2 3520             (          env.asm):00027                                 puls    y
74E4 39               (          env.asm):00028                                 rts
                      (          env.asm):00029         
                      (          env.asm):00030         ; >>> Add a default global binding
                      (          env.asm):00031         ; PASSED:  Y = addr of binding (name str, bound value)
                      (          env.asm):00032         ; RETURNS: Y = addr after the binding
                      (          env.asm):00033         ; ASSUMES: there is unallocated space for the ATOM name
74E5                  (          env.asm):00034         env$add$default$binding:
74E5 9E06             (          env.asm):00035                                 ldx             <atom_unalloc                                           ;X = new ATOM addr/ref
                      (          env.asm):00036         ;
74E7 3410             (          env.asm):00037                                 pshs    x                                                                       ;copy ATOM name to ATOM pool
74E9 A6A4             (          env.asm):00038                                 lda             ,y
74EB E6A0             (          env.asm):00039         @namelp         ldb             ,y+
74ED E780             (          env.asm):00040                                 stb             ,x+
74EF 4A               (          env.asm):00041                                 deca
74F0 2AF9             (          env.asm):00042                                 bpl             @namelp
74F2 9F06             (          env.asm):00043                                 stx             <atom_unalloc
                      (          env.asm):00044         ;
74F4 3506             (          env.asm):00045                                 puls    d                                                                       ;D = ATOM addr/ref
74F6 AEA1             (          env.asm):00046                                 ldx             ,y++                                                            ;X = bound value
74F8 8DD3             (          env.asm):00047                                 bsr             env$alloc$binding
74FA 1F10             (          env.asm):00048                                 tfr             x,d                                                                     ;D = ENV entry
74FC 9E08             (          env.asm):00049                                 ldx             <env_globals                                            ;X = global ENV
                      (          env.asm):00050                 ; fall through into ...
                      (          env.asm):00051         ; >>> Add an ATOM binding to an existing environment list
                      (          env.asm):00052         ; PASSED:  X = environment head, D = existing ATOM binding
                      (          env.asm):00053         ; ALTERS:  D
74FE                  (          env.asm):00054         env$add$binding:
74FE 3420             (          env.asm):00055                                 pshs    y
7500 10AE02           (          env.asm):00056                                 ldy             CC_CDR_OFF,x                                            ;old start of env
7503 ED02             (          env.asm):00057                                 std             CC_CDR_OFF,x                                            ;new start
7505 1E02             (          env.asm):00058                                 exg             d,y
7507 ED22             (          env.asm):00059                                 std             CC_CDR_OFF,y                                            ;old start is new second
7509 3520             (          env.asm):00060                                 puls    y
750B 39               (          env.asm):00061                                 rts
                      (          env.asm):00062         
                      (          env.asm):00063         ; >>> Define a binding in an ENV (replaces existing or creates new.)
                      (          env.asm):00064         ; PASSED:  D = ATOM to define; X = it's value; Y = ENV to define it within
750C                  (          env.asm):00065         env$def:
750C 8D21             (          env.asm):00066                                 bsr             env$cur                                                         ;Y = current ENV
750E                  (          env.asm):00067         env$def$in:
                      (          env.asm):00068         ;
                      (          env.asm):00069         ; See if it's already defined
                      (          env.asm):00070         ;
750E 3420             (          env.asm):00071                                 pshs    y
7510 10AE22           (          env.asm):00072                                 ldy             CC_CDR_OFF,y                                            ;Y = first binding
7513 270A             (          env.asm):00073                                 beq             @add                                                            ;if the ENV is empty
7515 10A3B4           (          env.asm):00074         @lp                     cmpd    [CC_CAR_OFF,y]
7518 270D             (          env.asm):00075                                 beq             @set                                                            ;if it's already defined
751A 10AE22           (          env.asm):00076                                 ldy             CC_CDR_OFF,y
751D 26F6             (          env.asm):00077                                 bne             @lp                                                                     ;else try next
                      (          env.asm):00078         ;
                      (          env.asm):00079         ; Not defined, add new definition
                      (          env.asm):00080         ;
751F 8DAC             (          env.asm):00081         @add            bsr             env$alloc$binding                                       ;allocate a new binding
7521 1F10             (          env.asm):00082                                 tfr             x,d                                                                     ;D = binding
7523 3510             (          env.asm):00083                                 puls    x                                                                       ;X = ENV head
7525 20D7             (          env.asm):00084                                 bra             env$add$binding                                         ;add it
                      (          env.asm):00085         ;
                      (          env.asm):00086         ; Already exists, set it's value
                      (          env.asm):00087         ;
7527 10AEA4           (          env.asm):00088         @set            ldy             CC_CAR_OFF,y                                            ;Y = binding CONS
752A AF22             (          env.asm):00089                                 stx             CC_CDR_OFF,y                                            ;store new value
752C 3262             (          env.asm):00090                                 leas    2,s                                                                     ;clean up the stack
752E 39               (          env.asm):00091                                 rts
                      (          env.asm):00092         
                      (          env.asm):00093         ; >>> Get the current environment (bottom-most on the U stack)
                      (          env.asm):00094         ; RETURNS: Y = current ENV (assumed to always succeed because the global ENV always exists)
                      (          env.asm):00095         ; ALTERS NO OTHER REGISTERS.
752F                  (          env.asm):00096         env$cur:
752F 3406             (          env.asm):00097                                 pshs    d
7531 1F32             (          env.asm):00098                                 tfr             u,y                                                                     ;Y = root pointers
7533 CC0006           (          env.asm):00099                                 ldd             #ATOM_env                                                       ;D = tag we're looking for
7536 10A3B1           (          env.asm):00100         @lp                     cmpd    [,y++]
7539 26FB             (          env.asm):00101                                 bne             @lp                                                                     ;keep going til we find one
753B 10AE3E           (          env.asm):00102                                 ldy             -2,y                                                            ;Y = current ENV
753E 3506             (          env.asm):00103                                 puls    d
7540 39               (          env.asm):00104                                 rts
                      (          env.asm):00105         
                      (          env.asm):00106         ; >>> Get ATOM's bound value or bail if it's unbound
                      (          env.asm):00107         ; Searches all of the environments on the Root Pointers stack from newest to oldest
                      (          env.asm):00108         ; PASSED:  X = addr/ref to ATOM
                      (          env.asm):00109         ; RETURNS: X = ref to CONS with binding (CDR is bound value)
                      (          env.asm):00110         ; DOES NOT ALTER Y.
                      (          env.asm):00111         ; Mucks with U reg but it's OK since there are no possible allocs/deallocs here.
7541                  (          env.asm):00112         env$get$atom$binding:
7541 3470             (          env.asm):00113                                 pshs    u,y,x                                                           ;,S = target ATOM
                      (          env.asm):00114         ;
7543 CC0006           (          env.asm):00115         @next$env       ldd             #ATOM_env                                                       ;D = tag for environments
7546 118313FF         (          env.asm):00116         @env$lp         cmpu    #ROOT_STACK_TOP-1
754A 2222             (          env.asm):00117                                 bhi             @unbound                                                        ;if hit top of stack then it's unbound
754C 10AEC1           (          env.asm):00118                                 ldy             ,u++                                                            ;Y = next root pointer
754F 10A3A4           (          env.asm):00119                                 cmpd    CC_CAR_OFF,y
7552 26F2             (          env.asm):00120                                 bne             @env$lp                                                         ;if it's not an environment
                      (          env.asm):00121         ;
7554 AE22             (          env.asm):00122                                 ldx             CC_CDR_OFF,y                                            ;X = first link in chain
7556 27EB             (          env.asm):00123                                 beq             @next$env                                                       ;if it's empty
7558 ECE4             (          env.asm):00124                                 ldd             ,s                                                                      ;D = target ATOM
755A 10A394           (          env.asm):00125         @atom$lp        cmpd    [CC_CAR_OFF,x]
755D 2706             (          env.asm):00126                                 beq             @bound                                                          ;if found a binding for the ATOM
755F AE02             (          env.asm):00127                                 ldx             CC_CDR_OFF,x                                            ;X = next link in ENV chain
7561 26F7             (          env.asm):00128                                 bne             @atom$lp                                                        ;if not done
7563 20DE             (          env.asm):00129                                 bra             @next$env                                                       ;else try next environment
                      (          env.asm):00130         ;
7565 AE84             (          env.asm):00131         @bound          ldx             CC_CAR_OFF,x                                            ;X = CONS with binding
7567 AFE4             (          env.asm):00132                                 stx             ,s
7569 3570             (          env.asm):00133                                 puls    x,y,u
756B 1A04             (          env.asm):00134                                 orcc    #$04                                                            ;return EQ
756D 39               (          env.asm):00135                                 rts
                      (          env.asm):00136         ;
756E 3570             (          env.asm):00137         @unbound        puls    x,y,u                                                           ;restore regs
7570 BD707D           (          env.asm):00138                                 jsr             bail$ref                                                        ;and bail
7573 09756E626F756E64 (          env.asm):00139                                 fcb             9,'u','n','b','o','u','n','d','!',BEL
     2107
                      (    ./src/syl.asm):00354                         include "print.asm"
                      (        print.asm):00001         ; "print.asm" - Print an S-Expression for Syl
                      (        print.asm):00002         ; 2023-feb-20 dww  created
                      (        print.asm):00003         
                      (        print.asm):00004         ; >>> Evaluate an S-Expression
                      (        print.asm):00005         ; PASSED:  X = root pointer of the S-Expression
                      (        print.asm):00006         ; RETURNS: X = root pointer of the result
757D                  (        print.asm):00007         print:
757D BD75DA           (        print.asm):00008                                 jsr             ref$is$int
7580 2719             (        print.asm):00009                                 beq             @int                                                    ;if it's an integer
7582 BD75E2           (        print.asm):00010                                 jsr             ref$is$atom
7585 271F             (        print.asm):00011                                 beq             @atom                                                   ;if it's an ATOM
7587 BD75EA           (        print.asm):00012                                 jsr             ref$is$cons
758A 271D             (        print.asm):00013                                 beq             @cons                                                   ;if it's a CONS cell
758C BD75F6           (        print.asm):00014                                 jsr             ref$is$bis
758F 2741             (        print.asm):00015                                 beq             @bifn                                                   ;if it's a built-in function
                      (        print.asm):00016         ;
                      (        print.asm):00017         ; UNKNOWN
                      (        print.asm):00018         ;
7591 C63F             (        print.asm):00019                                 ldb             #'?'
7593 BD7AB3           (        print.asm):00020         @putc           jsr             con$putc
7596 1F10             (        print.asm):00021                                 tfr             x,d
7598 7E7AE5           (        print.asm):00022                                 jmp             con$disp$hex$word
                      (        print.asm):00023         ;
                      (        print.asm):00024         ; INTEGER
                      (        print.asm):00025         ;
759B 1F10             (        print.asm):00026         @int            tfr             x,d
759D 8540             (        print.asm):00027                                 bita    #$40
759F 2602             (        print.asm):00028                                 bne             @disp$int                                               ;negative number is OK as-is
75A1 847F             (        print.asm):00029                                 anda    #CCS_INT_MASK/256                               ;else clear MSB for positive
75A3 7E7B08           (        print.asm):00030         @disp$int       jmp             con$disp$int$word                               ;display as signed decimal
                      (        print.asm):00031         ;
                      (        print.asm):00032         ; ATOM
                      (        print.asm):00033         ;
75A6 7E7AD5           (        print.asm):00034         @atom           jmp             con$msg                                                 ;ref is name addr
                      (        print.asm):00035         ;
                      (        print.asm):00036         ; CONS
                      (        print.asm):00037         ;
75A9 C628             (        print.asm):00038         @cons           ldb             #'('                                                    ;open paren
75AB BD7AB3           (        print.asm):00039                                 jsr             con$putc
                      (        print.asm):00040         ;
75AE 3410             (        print.asm):00041         @conslp         pshs    x                                                               ;display CAR
75B0 AE84             (        print.asm):00042                                 ldx             CC_CAR_OFF,x
75B2 8DC9             (        print.asm):00043                                 bsr             print
75B4 3510             (        print.asm):00044                                 puls    x
                      (        print.asm):00045         ;
75B6 AE02             (        print.asm):00046                                 ldx             CC_CDR_OFF,x
75B8 2713             (        print.asm):00047                                 beq             @consend                                                ;we're done if it's NIL
75BA BD75EA           (        print.asm):00048                                 jsr             ref$is$cons
75BD 2607             (        print.asm):00049                                 bne             @dotted                                                 ;if it's a dotted pair
                      (        print.asm):00050         ;
75BF C620             (        print.asm):00051                                 ldb             #' '                                                    ;else it's a list
75C1 BD7AB3           (        print.asm):00052                                 jsr             con$putc
75C4 20E8             (        print.asm):00053                                 bra             @conslp
                      (        print.asm):00054         ;
75C6 C62E             (        print.asm):00055         @dotted         ldb             #'.'                                                    ;display as dotted pair
75C8 BD7AB3           (        print.asm):00056                                 jsr             con$putc
75CB 8DB0             (        print.asm):00057                                 bsr             print
                      (        print.asm):00058         ;
75CD C629             (        print.asm):00059         @consend        ldb             #')'                                                    ;close paren
75CF 7E7AB3           (        print.asm):00060                                 jmp             con$putc
                      (        print.asm):00061         ;
                      (        print.asm):00062         ; Built-in Function
                      (        print.asm):00063         ;
75D2 30896EE2         (        print.asm):00064         @bifn           leax    bis$base-CCS_REF_BIV_FIRST,x    ;X = actual address
75D6 C640             (        print.asm):00065                                 ldb             #'@'
75D8 20B9             (        print.asm):00066                                 bra             @putc                                                   ;rest same as unknown
                      (    ./src/syl.asm):00355                         include "cons.asm"
                      (         cons.asm):00001         ; "cons.asm" - CONS pool management for Syl
                      (         cons.asm):00002         ; 2023-feb-20 dww created
                      (         cons.asm):00003         
                      (         cons.asm):00004         ; >>> Test if CONS Slot Ref is an integer
                      (         cons.asm):00005         ; PASSED:  X = CONS slot ref
                      (         cons.asm):00006         ; RETURNS: EQ if it's an integer else NE
75DA                  (         cons.asm):00007         ref$is$int:
75DA 8C8000           (         cons.asm):00008                                 cmpx    #CCS_TYPE_INT
75DD 2502             (         cons.asm):00009                                 blo             @ret                                                    ;if not an integer
75DF 1A04             (         cons.asm):00010         @eq                     orcc    #$04                                                    ;else return EQ
75E1 39               (         cons.asm):00011         @ret            rts
                      (         cons.asm):00012         ;
                      (         cons.asm):00013         ;
                      (         cons.asm):00014         ; >>> Test if CONS Slot Ref is an ATOM
                      (         cons.asm):00015         ; PASSED:  X = CONS slot ref
                      (         cons.asm):00016         ; RETURNS: EQ if it's an ATOM else NE
75E2                  (         cons.asm):00017         ref$is$atom:
75E2 8C0800           (         cons.asm):00018                                 cmpx    #CCS_REF_ATOM_END
75E5 25F8             (         cons.asm):00019                                 blo             @eq                                                             ;if it is an ATOM
75E7 1CFB             (         cons.asm):00020         @ne                     andcc   #~$04                                                   ;else return NE
75E9 39               (         cons.asm):00021                                 rts
                      (         cons.asm):00022         ;
                      (         cons.asm):00023         ; >>> Test if CONS Slot Ref is a CONS cell
                      (         cons.asm):00024         ; PASSED:  D = CONS slot ref
                      (         cons.asm):00025         ; RETURNS: EQ if it's a CONS cell else NE
75EA                  (         cons.asm):00026         ref$is$cons:
75EA 8C1400           (         cons.asm):00027                                 cmpx    #CCS_REF_CONS_FIRST
75ED 25F8             (         cons.asm):00028                                 blo             @ne                                                             ;if it's not a CONS cell
75EF 8C7000           (         cons.asm):00029                                 cmpx    #CCS_REF_CONS_END
75F2 25EB             (         cons.asm):00030         @blo            blo             @eq                                                             ;if it is
75F4 20F1             (         cons.asm):00031                                 bra             @ne                                                             ;else it's not
                      (         cons.asm):00032         ;
                      (         cons.asm):00033         ; >>> Test if CONS Slot Ref is to a built-in
                      (         cons.asm):00034         ; PASSED:  D = CONS slot ref
                      (         cons.asm):00035         ; RETURNS: EQ if it's a built-in function else NE
75F6                  (         cons.asm):00036         ref$is$bis:
75F6 8C0800           (         cons.asm):00037                                 cmpx    #CCS_REF_BIS_FIRST
75F9 25EC             (         cons.asm):00038                                 blo             @ne                                                             ;if it's not a built-in
75FB 8C1000           (         cons.asm):00039                                 cmpx    #CCS_REF_BIS_END
75FE 20F2             (         cons.asm):00040                                 bra             @blo                                                    ;finish like CONS
                      (         cons.asm):00041         
                      (         cons.asm):00042         ; >>> Allocate a CONS cell with a specific CAR tag value
                      (         cons.asm):00043         ; PASSED:  D = desired CAR tag value
                      (         cons.asm):00044         ; RETURNS: X = pointer/ref to a CONS cell
                      (         cons.asm):00045         ; NOTE: Doesn't return if memory is totally exhausted
7600                  (         cons.asm):00046         cons$alloc$tag:
7600 3406             (         cons.asm):00047                                 pshs    d
7602 8D05             (         cons.asm):00048                                 bsr             cons$alloc
7604 3506             (         cons.asm):00049                                 puls    d
7606 ED84             (         cons.asm):00050                                 std             CC_CAR_OFF,x
7608 39               (         cons.asm):00051                                 rts
                      (         cons.asm):00052         
                      (         cons.asm):00053         ; >>> Allocate a CONS Cell
                      (         cons.asm):00054         ; RETURNS: X = pointer/ref to a CONS cell
                      (         cons.asm):00055         ; NOTE: Doesn't return if memory is totally exhausted
7609                  (         cons.asm):00056         cons$alloc:
7609 9E00             (         cons.asm):00057                                 ldx             <cons_free_list                                         ;try the free list
760B 2712             (         cons.asm):00058                                 beq             @unalloc                                                        ;if it's empty
                      (         cons.asm):00059         ;
760D EC02             (         cons.asm):00060         @unlink         ldd             CC_CDR_OFF,x                                            ;unlink it
760F DD00             (         cons.asm):00061                                 std             <cons_free_list
7611 CCFFFF           (         cons.asm):00062                                 ldd             #-1
7614 D302             (         cons.asm):00063                                 addd    <cons_free_count
7616 DD02             (         cons.asm):00064                                 std             <cons_free_count
                      (         cons.asm):00065         ;
7618 4F               (         cons.asm):00066         @init           clra                                                                            ;init to NILs
7619 5F               (         cons.asm):00067                                 clrb
761A ED84             (         cons.asm):00068                                 std             CC_CAR_OFF,x
761C ED02             (         cons.asm):00069                                 std             CC_CDR_OFF,x
761E 39               (         cons.asm):00070                                 rts
                      (         cons.asm):00071         ;
761F 9E04             (         cons.asm):00072         @unalloc        ldx             <cons_unalloc                                           ;can we allocate a new one?
7621 8C7000           (         cons.asm):00073                                 cmpx    #CONS_POOL_END
7624 2409             (         cons.asm):00074                                 bhs             @gc                                                                     ;nope, need to garbage collect
7626 1F10             (         cons.asm):00075                                 tfr             x,d                                                                     ;yep, update unallocated pointer
7628 C30004           (         cons.asm):00076                                 addd    #CC_SIZE
762B DD04             (         cons.asm):00077                                 std             <cons_unalloc
762D 20E9             (         cons.asm):00078                                 bra             @init                                                           ;and init it to NILs
                      (         cons.asm):00079         ;
762F 8D22             (         cons.asm):00080         @gc                     bsr             gc$run                                                          ;collect the garbage
7631 9E00             (         cons.asm):00081                                 ldx             <cons_free_list                                         ;get the first freed
7633 26D8             (         cons.asm):00082                                 bne             @unlink                                                         ;if got at least one
                      (         cons.asm):00083         ;
7635 BD7056           (         cons.asm):00084                                 jsr             bail                                                            ;else memory is full
7638 0A4D656D2066756C (         cons.asm):00085                                 fcb             10,'M','e','m',' ','f','u','l','l','!',BEL
     6C2107
                      (    ./src/syl.asm):00356                         include "gc.asm"
                      (           gc.asm):00001         ; "gc.asm" - Garbage Collection support for Syl
                      (           gc.asm):00002         ; 2023-feb-21 dww  created
                      (           gc.asm):00003         ;
                      (           gc.asm):00004         ; Your basic stop-the-world garbage collector for CONS cells.
                      (           gc.asm):00005         ;
                      (           gc.asm):00006         ; Walks through all currently live CONS refs marking them and
                      (           gc.asm):00007         ; any other CONS cells they reference as live in the GC mark pool.
                      (           gc.asm):00008         ; Then a sweep through all allocated cells adds any that are NOT
                      (           gc.asm):00009         ; marked as live to the free list. The free list is built from
                      (           gc.asm):00010         ; scratch on every GC.
                      (           gc.asm):00011         ;
                      (           gc.asm):00012         ; It is assumed that ONLY those refs rooted on items on the U stack
                      (           gc.asm):00013         ; are live. So if a function needs to protect a reference from the
                      (           gc.asm):00014         ; garbage collector it should push it on the U stack then pop it
                      (           gc.asm):00015         ; off when it's finished. The GC ignores non-CONS items on the U
                      (           gc.asm):00016         ; stack. Also never push anything that's not cell ref (ATOM, CONS,
                      (           gc.asm):00017         ; BIS, INT) on the U stack if there's a change the GC will see it
                      (           gc.asm):00018         ; otherwise Bad Things may happen.
                      (           gc.asm):00019         ;
                      (           gc.asm):00020         ; At the moment the ATOM pool is NOT garbage collected so when you
                      (           gc.asm):00021         ; run out of ATOM space you're screwed and have to restart the
                      (           gc.asm):00022         ; interpreter. Not that common since only unique ATOM names get
                      (           gc.asm):00023         ; stored there. GCing the ATOM pool is possible but kind of hairy.
                      (           gc.asm):00024         ; Assign 1 bit from the GC MARK pool for each byte of ATOM space.
                      (           gc.asm):00025         ; Walk the U stack and for every ATOM you find mark the assoc. bytes
                      (           gc.asm):00026         ; as live in the mark pool. Then scan the mark pool moving ATOM bytes
                      (           gc.asm):00027         ; down to fill in the free gaps and also build a table mapping offsets
                      (           gc.asm):00028         ; into the ATOM pool with the (negative) offset to add to shift it
                      (           gc.asm):00029         ; to it's new ATOM pool offset. Then walk the U stack again and use
                      (           gc.asm):00030         ; the offset table to adjust all of the ATOMs to their new values.
                      (           gc.asm):00031         ; Now you know why I decided not to do that just yet.
                      (           gc.asm):00032         
                      (           gc.asm):00033         ; >>> Free bytes
                      (           gc.asm):00034         ; RETURNS: X = free cell count as Int ref
7643                  (           gc.asm):00035         gc$free:
7643 CC7000           (           gc.asm):00036                                 ldd             #CONS_POOL_END
7646 9304             (           gc.asm):00037                                 subd    <cons_unalloc                                                   ; = unallocated bytes
7648 44               (           gc.asm):00038                                 lsra
7649 56               (           gc.asm):00039                                 rorb
764A 44               (           gc.asm):00040                                 lsra
764B 56               (           gc.asm):00041                                 rorb                                                                                    ; = unallocated cell count
764C D302             (           gc.asm):00042                                 addd    <cons_free_count                                                ; + count in free list
764E 8A80             (           gc.asm):00043                                 ora             #CCS_TYPE_INT/256
7650 1F01             (           gc.asm):00044                                 tfr             d,x
7652 39               (           gc.asm):00045                                 rts
                      (           gc.asm):00046         
                      (           gc.asm):00047         ; >>> Run a garbage collection cycle
                      (           gc.asm):00048         ; Assumes gc_mark_pool is already zeroed.
7653                  (           gc.asm):00049         gc$run:
7653 3440             (           gc.asm):00050                                 pshs    u                                                                               ;we're going to bach U so save to restore later
                      (           gc.asm):00051         ;
                      (           gc.asm):00052         ; Mark all entries on the Root Stack as LIVE
                      (           gc.asm):00053         ;
7655 11831400         (           gc.asm):00054         @rootlp         cmpu    #ROOT_STACK_TOP
7659 2454             (           gc.asm):00055                                 bhs             @sweep                                                                  ;if we're all done
765B 10AEC1           (           gc.asm):00056                                 ldy             ,u++                                                                    ;next root ref
765E 8D02             (           gc.asm):00057                                 bsr             @marky?                                                                 ;mark it if needed
7660 20F3             (           gc.asm):00058                                 bra             @rootlp
                      (           gc.asm):00059         ;
7662 108C1400         (           gc.asm):00060         @marky?         cmpy    #CCS_REF_CONS_FIRST
7666 2506             (           gc.asm):00061                                 blo             @ret                                                                    ;if not a CONS
7668 108C7000         (           gc.asm):00062                                 cmpy    #CCS_REF_CONS_END
766C 2501             (           gc.asm):00063                                 blo             @marky                                                                  ;if it *is* a CONS
766E 39               (           gc.asm):00064         @ret            rts                                                                                             ;else we're done
                      (           gc.asm):00065         ;
766F 10AFE3           (           gc.asm):00066         @marky          sty             ,--s                                                                    ;mark Y as LIVE in GC pool
7672 1F29             (           gc.asm):00067                                 tfr             y,b
7674 54               (           gc.asm):00068                                 lsrb                                                                                    ;low 2 bits are intra-cell
7675 54               (           gc.asm):00069                                 lsrb
7676 CAF8             (           gc.asm):00070                                 orb             #%11111000
7678 1F91             (           gc.asm):00071                                 tfr             b,x                                                                             ;X = bit mask offset (0..7 -> -8..-1)
767A 1F20             (           gc.asm):00072                                 tfr             y,d                                                                             ;D = CONS ref
767C 831400           (           gc.asm):00073                                 subd    #CCS_REF_CONS_FIRST                                             ;D = offset into CONS pool
767F 44               (           gc.asm):00074                                 lsra
7680 56               (           gc.asm):00075                                 rorb
7681 44               (           gc.asm):00076                                 lsra
7682 56               (           gc.asm):00077                                 rorb
7683 44               (           gc.asm):00078                                 lsra
7684 56               (           gc.asm):00079                                 rorb
7685 44               (           gc.asm):00080                                 lsra
7686 56               (           gc.asm):00081                                 rorb
7687 44               (           gc.asm):00082                                 lsra
7688 56               (           gc.asm):00083                                 rorb                                                                                    ;D = byte offset into MARK pool
7689 1F02             (           gc.asm):00084                                 tfr             d,y
768B E6A90864         (           gc.asm):00085                                 ldb             gc_mark_pool,y                                                  ;turn ON MARK bit
768F EA8976AF         (           gc.asm):00086                                 orb             @bits,x
7693 E7A90864         (           gc.asm):00087                                 stb             gc_mark_pool,y
                      (           gc.asm):00088         ;
7697 10AEE4           (           gc.asm):00089                                 ldy             ,s                                                                              ;mark CAR if needed
769A 10AEA4           (           gc.asm):00090                                 ldy             CC_CAR_OFF,y
769D 8DC3             (           gc.asm):00091                                 bsr             @marky?
769F 10AEE1           (           gc.asm):00092                                 ldy             ,s++                                                                    ;mark CDR if needed
76A2 10AE22           (           gc.asm):00093                                 ldy             CC_CDR_OFF,y
76A5 20BB             (           gc.asm):00094                                 bra             @marky?
                      (           gc.asm):00095         ;
76A7 0102040810204080 (           gc.asm):00096                                 fcb             $01,$02,$04,$08,$10,$20,$40,$80                 ;indexed with negative offset
76AF                  (           gc.asm):00097         @bits:
                      (           gc.asm):00098         ;
                      (           gc.asm):00099         ; Sweep CONS POOL looking for unmarked cells to add to the free list.
                      (           gc.asm):00100         ; We sweep 8 cells per loop (a SYL.ASM assertion ensures the pool size is a multiple of 8 cells)
                      (           gc.asm):00101         ; The sweep stops at the first unallocated. Doesn't matter if it's not a multiple of 8 cells
                      (           gc.asm):00102         ; as any extra unallocated will just get added to the free list.
                      (           gc.asm):00103         ;
76AF CE0864           (           gc.asm):00104         @sweep          ldu             #gc_mark_pool                                                   ;U = MARK pool index
76B2 108E1400         (           gc.asm):00105                                 ldy             #CCS_REF_CONS_FIRST                                             ;Y = associated CONS cell ref
                      (           gc.asm):00106         ;
76B6 8E0000           (           gc.asm):00107                                 ldx             #0                                                                              ;start with empty free list
76B9 9F02             (           gc.asm):00108                                 stx             <cons_free_count
                      (           gc.asm):00109         ;
76BB E6C4             (           gc.asm):00110         @sweep8         ldb             ,u                                                                              ;load next 8 MARKs
76BD 6FC0             (           gc.asm):00111                                 clr             ,u+                                                                             ;and clear them for next time
76BF 8608             (           gc.asm):00112                                 lda             #8
76C1 109C04           (           gc.asm):00113         @sweeplp        cmpy    <cons_unalloc
76C4 2414             (           gc.asm):00114                                 bhs             @done                                                                   ;if done with allocated cells
76C6 54               (           gc.asm):00115                                 lsrb
76C7 250A             (           gc.asm):00116                                 bcs             @swnext                                                                 ;if this cell is LIVE
76C9 AF22             (           gc.asm):00117                                 stx             CC_CDR_OFF,y                                                    ;else add to free list
76CB 9E02             (           gc.asm):00118                                 ldx             <cons_free_count
76CD 3001             (           gc.asm):00119                                 leax    1,x
76CF 9F02             (           gc.asm):00120                                 stx             <cons_free_count
76D1 1F21             (           gc.asm):00121                                 tfr             y,x
                      (           gc.asm):00122         ;
76D3 3124             (           gc.asm):00123         @swnext         leay    CC_SIZE,y                                                               ;next cell
76D5 4A               (           gc.asm):00124                                 deca
76D6 26E9             (           gc.asm):00125                                 bne             @sweeplp
76D8 20E1             (           gc.asm):00126                                 bra             @sweep8                                                                 ;if need to load next 8
                      (           gc.asm):00127         ;
                      (           gc.asm):00128         ; All done.
                      (           gc.asm):00129         ;
76DA 9F00             (           gc.asm):00130         @done           stx             <cons_free_list                                                 ;updated free list head
76DC 3540             (           gc.asm):00131                                 puls    u                                                                               ;restore the root stack pointer
76DE 8E0000           (           gc.asm):00132                                 ldx             #ATOM_NIL                                                               ;return NIL
76E1 39               (           gc.asm):00133                                 rts
                      (    ./src/syl.asm):00357                         include "bis.asm"
                      (          bis.asm):00001         ; "bis.asm" - Implementations for Built-ins for Syl.
                      (          bis.asm):00002         ; 2023-feb-21 dww  created
                      (          bis.asm):00003         ;
                      (          bis.asm):00004         ; Built-Ins refer to values and functions implemented in 6809
                      (          bis.asm):00005         ; code as part of the interpreter itself. Syl refs other than Ints are
                      (          bis.asm):00006         ; essentially pointers into specific memory ranges that hold each type
                      (          bis.asm):00007         ; of data (ATOMs, CONS, etc). Can't really do that for Built-Ins since
                      (          bis.asm):00008         ; the ROM address range they occupy are part of the Integer ref space.
                      (          bis.asm):00009         ; So instead we use the range of addresses for variables (VAR_ORG..VAR_END)
                      (          bis.asm):00010         ; as an offset into this built-in function module. That means we're limited
                      (          bis.asm):00011         ; to VAR_SIZE values (1K at the moment) so all the built-ins must at least
                      (          bis.asm):00012         ; start in 1KB of space. If that becomes an issue I can use a vector table
                      (          bis.asm):00013         ; instead of a plain offset but we'll cross that bridge when it's officially
                      (          bis.asm):00014         ; in flames.
                      (          bis.asm):00015         ;
                      (          bis.asm):00016         ; There are three different types of built-ins: values (BIVs), functions (BIFs)
                      (          bis.asm):00017         ; and quoted functions (BIQs). BIFs args are passed evaluated but BIQs are not.
                      (          bis.asm):00018         ; Each type occupies a separate range of offsets so we can tell them apart.
                      (          bis.asm):00019         
                      (          bis.asm):00020         ; >>> Base address for all built-in references:
     76E2             (          bis.asm):00021         bis$base        equ             *
                      (          bis.asm):00022         
                      (          bis.asm):00023         ;@@@
                      (          bis.asm):00024         ;@@@ BUILT-IN VALUES
                      (          bis.asm):00025         ;@@@
     76E2             (          bis.asm):00026         biv$base        equ             *
                      (          bis.asm):00027         
                      (          bis.asm):00028         ; >>> Syl version
     0800             (          bis.asm):00029         BIV_VER         equ             *-bis$base+CCS_REF_BIS_FIRST
76E2 8E800D           (          bis.asm):00030                                 ldx             #SYL_VER*10+SYL_REV+CCS_TYPE_INT
76E5 39               (          bis.asm):00031                                 rts
                      (          bis.asm):00032         
                      (          bis.asm):00033         ; >>> Current ENVironment
     0804             (          bis.asm):00034         BIV_ENV         equ             *-bis$base+CCS_REF_BIS_FIRST
76E6 BD752F           (          bis.asm):00035                                 jsr             env$cur
76E9 1F21             (          bis.asm):00036                                 tfr             y,x
76EB 39               (          bis.asm):00037                                 rts
                      (          bis.asm):00038         
                      (          bis.asm):00039         ; >>> Current free CONS cell count
     080A             (          bis.asm):00040         BIV_FREE        equ             *-bis$base+CCS_REF_BIS_FIRST
76EC 7E7643           (          bis.asm):00041                                 jmp             gc$free
                      (          bis.asm):00042         
     76EF             (          bis.asm):00043         biv$end         equ             *
                      (          bis.asm):00044         ;
     0800             (          bis.asm):00045         CCS_REF_BIV_FIRST       equ             biv$base-bis$base+CCS_REF_BIS_FIRST
     080D             (          bis.asm):00046         CCS_REF_BIV_END         equ             biv$end-bis$base+CCS_REF_BIS_FIRST
                      (          bis.asm):00047         
                      (          bis.asm):00048         ;@@@
                      (          bis.asm):00049         ;@@@ BUILT-IN FUNCTIONS (X = EVALUATED ARGS)
                      (          bis.asm):00050         ;@@@
     76EF             (          bis.asm):00051         bif$base        equ             *
                      (          bis.asm):00052         
                      (          bis.asm):00053         ;@@@ BASIC LIST MANIPULATION
                      (          bis.asm):00054         
                      (          bis.asm):00055         ; >>> (CAR e)
     080D             (          bis.asm):00056         BIF_CAR         equ             *-bis$base+CCS_REF_BIS_FIRST
76EF AE94             (          bis.asm):00057                                 ldx             [CC_CAR_OFF,x]                                          ;X = (CAR arg1)
76F1 39               (          bis.asm):00058                                 rts
                      (          bis.asm):00059         
                      (          bis.asm):00060         ; >>> (CDR e)
     0810             (          bis.asm):00061         BIF_CDR         equ             *-bis$base+CCS_REF_BIS_FIRST
76F2 AE84             (          bis.asm):00062                                 ldx             CC_CAR_OFF,x                                            ;X = arg1
76F4 AE02             (          bis.asm):00063                                 ldx             CC_CDR_OFF,x                                            ;value = (CDR x)
76F6 39               (          bis.asm):00064                                 rts
                      (          bis.asm):00065         
     0815             (          bis.asm):00066         BIF_CADR        equ             *-bis$base+CCS_REF_BIS_FIRST
76F7 AE84             (          bis.asm):00067                                 ldx             CC_CAR_OFF,x                                            ;X = arg
76F9 AE9802           (          bis.asm):00068         @cadr           ldx             [CC_CDR_OFF,x]                                          ;X = (CAR (CDR arg))
76FC 39               (          bis.asm):00069                                 rts
                      (          bis.asm):00070         ;
     081B             (          bis.asm):00071         BIF_CADDR       equ             *-bis$base+CCS_REF_BIS_FIRST
76FD AE84             (          bis.asm):00072                                 ldx             CC_CAR_OFF,x                                            ;X = arg
76FF AE02             (          bis.asm):00073                                 ldx             CC_CDR_OFF,x                                            ;X = (CDR arg)
7701 20F6             (          bis.asm):00074                                 bra             @cadr
                      (          bis.asm):00075         
     0821             (          bis.asm):00076         BIF_CDDR        equ             *-bis$base+CCS_REF_BIS_FIRST
7703 AE84             (          bis.asm):00077                                 ldx             CC_CAR_OFF,x                                            ;X = arg
7705 AE02             (          bis.asm):00078                                 ldx             CC_CDR_OFF,x
7707 AE02             (          bis.asm):00079                                 ldx             CC_CDR_OFF,x                                            ;X = (CDDR arg)
7709 39               (          bis.asm):00080                                 rts
                      (          bis.asm):00081         
                      (          bis.asm):00082         ; >>> (CONS e1 e2)
     0828             (          bis.asm):00083         BIF_CONS        equ             *-bis$base+CCS_REF_BIS_FIRST
770A EC84             (          bis.asm):00084                                 ldd             CC_CAR_OFF,x                                            ;new CAR
770C AE9802           (          bis.asm):00085                                 ldx             [CC_CDR_OFF,x]                                          ;new CDR
770F 3616             (          bis.asm):00086                                 pshu    x,d
7711 BD7609           (          bis.asm):00087                                 jsr             cons$alloc                                                      ;allocate a CONS cell
7714 3706             (          bis.asm):00088                                 pulu    d
7716 ED84             (          bis.asm):00089                                 std             CC_CAR_OFF,x                                            ;set CAR
7718 3706             (          bis.asm):00090                                 pulu    d
771A ED02             (          bis.asm):00091                                 std             CC_CDR_OFF,x                                            ;set CDR
771C 39               (          bis.asm):00092                                 rts
                      (          bis.asm):00093         
                      (          bis.asm):00094         ; >>> (LIST e1 e2 ...)
     083B             (          bis.asm):00095         BIF_LIST        equ             *-bis$base+CCS_REF_BIS_FIRST
771D 39               (          bis.asm):00096                                 rts
                      (          bis.asm):00097         
                      (          bis.asm):00098         ; >>> (RPLACA c e)
     083C             (          bis.asm):00099         BIF_RPLACA      equ             *-bis$base+CCS_REF_BIS_FIRST
771E EC84             (          bis.asm):00100                                 ldd             CC_CAR_OFF,x
7720 AE9802           (          bis.asm):00101                                 ldx             [CC_CDR_OFF,x]
7723 1E01             (          bis.asm):00102                                 exg             d,x                                                                     ;X = CONS, D = new CAR
7725 ED84             (          bis.asm):00103                                 std             CC_CAR_OFF,x
7727 39               (          bis.asm):00104                                 rts
                      (          bis.asm):00105         
                      (          bis.asm):00106         ; >>> (RPLACD c e)
     0846             (          bis.asm):00107         BIF_RPLACD      equ             *-bis$base+CCS_REF_BIS_FIRST
7728 EC84             (          bis.asm):00108                                 ldd             CC_CAR_OFF,x
772A AE9802           (          bis.asm):00109                                 ldx             [CC_CDR_OFF,x]
772D 1E01             (          bis.asm):00110                                 exg             d,x                                                                     ;X = CONS, D = new CDR
772F ED02             (          bis.asm):00111                                 std             CC_CDR_OFF,x
7731 39               (          bis.asm):00112                                 rts
                      (          bis.asm):00113         
                      (          bis.asm):00114         ;@@@ PREDICATES
                      (          bis.asm):00115         
                      (          bis.asm):00116         ; >>> (ATOM e)
     0850             (          bis.asm):00117         BIF_ATOM        equ             *-bis$base+CCS_REF_BIS_FIRST
7732 AE84             (          bis.asm):00118                                 ldx             CC_CAR_OFF,x                                            ;argument
7734 BD75E2           (          bis.asm):00119                                 jsr             ref$is$atom
7737 2704             (          bis.asm):00120         ret$bool        beq             ret$true                                                        ;if it is an ATOM
                      (          bis.asm):00121         ;
7739 8E0000           (          bis.asm):00122         ret$nil:        ldx             #ATOM_NIL                                                       ;return NIL/F
773C 39               (          bis.asm):00123                                 rts
                      (          bis.asm):00124         ;
773D 8E0004           (          bis.asm):00125         ret$true:       ldx             #ATOM_T                                                         ;return T
7740 39               (          bis.asm):00126                                 rts
                      (          bis.asm):00127         
                      (          bis.asm):00128         ; >>> (NULL e)
     085F             (          bis.asm):00129         BIF_NULL        equ             *-bis$base+CCS_REF_BIS_FIRST
7741 AE84             (          bis.asm):00130                                 ldx             CC_CAR_OFF,x                                            ;argument
7743 20F2             (          bis.asm):00131                                 bra             ret$bool
                      (          bis.asm):00132         
                      (          bis.asm):00133         ; >>> (EQ e1 e2)
     0863             (          bis.asm):00134         BIF_EQ          equ             *-bis$base+CCS_REF_BIS_FIRST
7745 EC84             (          bis.asm):00135                                 ldd             CC_CAR_OFF,x                                            ;arg1
7747 10A39802         (          bis.asm):00136                                 cmpd    [CC_CDR_OFF,x]                                          ;compare to arg2
774B 20EA             (          bis.asm):00137                                 bra             ret$bool
                      (          bis.asm):00138         
                      (          bis.asm):00139         ; >>> (EQUAL e1 e2)
     086B             (          bis.asm):00140         BIF_EQUAL       equ             *-bis$base+CCS_REF_BIS_FIRST
774D EC84             (          bis.asm):00141                                 ldd             CC_CAR_OFF,x                                            ;D = arg1
774F AE9802           (          bis.asm):00142                                 ldx             [CC_CDR_OFF,x]                                          ;X = arg2
7752 8D02             (          bis.asm):00143                                 bsr             @equal                                                          ;recursive compare
7754 20E1             (          bis.asm):00144                                 bra             ret$bool
                      (          bis.asm):00145         ;
7756 3410             (          bis.asm):00146         @equal          pshs    x
7758 10A3E1           (          bis.asm):00147                                 cmpd    ,s++
775B 2722             (          bis.asm):00148                                 beq             @ret                                                            ;if they're the same
                      (          bis.asm):00149         ;
775D BD75EA           (          bis.asm):00150                                 jsr             ref$is$cons
7760 261D             (          bis.asm):00151                                 bne             @ret                                                            ;nope, and they're not CONS
7762 1E01             (          bis.asm):00152                                 exg             d,x
7764 BD75EA           (          bis.asm):00153                                 jsr             ref$is$cons
7767 2616             (          bis.asm):00154                                 bne             @ret                                                            ;ditto
                      (          bis.asm):00155         ;
7769 3416             (          bis.asm):00156                                 pshs    x,d                                                                     ;compare CARs
776B EC84             (          bis.asm):00157                                 ldd             CC_CAR_OFF,x
776D AEF4             (          bis.asm):00158                                 ldx             [,s]
776F 8DE5             (          bis.asm):00159                                 bsr             @equal
7771 3516             (          bis.asm):00160                                 puls    d,x
7773 260A             (          bis.asm):00161                                 bne             @ret                                                            ;if they're not equal
                      (          bis.asm):00162         ;
7775 3406             (          bis.asm):00163                                 pshs    d                                                                       ;compare CDRs
7777 EC02             (          bis.asm):00164                                 ldd             CC_CDR_OFF,x
7779 3510             (          bis.asm):00165                                 puls    x
777B AE02             (          bis.asm):00166                                 ldx             CC_CDR_OFF,x
777D 8DD7             (          bis.asm):00167                                 bsr             @equal
777F 39               (          bis.asm):00168         @ret            rts                                                                                     ;return EQ if EQUAL else NE
                      (          bis.asm):00169         
                      (          bis.asm):00170         ; >>> (NOT e)
     089E             (          bis.asm):00171         BIF_NOT         equ             *-bis$base+CCS_REF_BIS_FIRST
7780 EC84             (          bis.asm):00172                                 ldd             CC_CAR_OFF,x                                            ;arg
7782 20B3             (          bis.asm):00173                                 bra             ret$bool
                      (          bis.asm):00174         
                      (          bis.asm):00175         ; >>> (!= e1 e2)
     08A2             (          bis.asm):00176         BIF_NE          equ             *-bis$base+CCS_REF_BIS_FIRST
7784 EC84             (          bis.asm):00177                                 ldd             CC_CAR_OFF,x                                            ;arg1
7786 10A39802         (          bis.asm):00178                                 cmpd    [CC_CDR_OFF,x]                                          ;compare to arg2
778A 26B1             (          bis.asm):00179                                 bne             ret$true
778C 20AB             (          bis.asm):00180                                 bra             ret$nil
                      (          bis.asm):00181         
     08AC             (          bis.asm):00182         BIF_LT          equ             *-bis$base+CCS_REF_BIS_FIRST
778E 8D16             (          bis.asm):00183                                 bsr             cmp$int$args                                            ;compare arg1, arg2
7790 2DAB             (          bis.asm):00184                                 blt             ret$true
7792 20A5             (          bis.asm):00185                                 bra             ret$nil
                      (          bis.asm):00186         
     08B2             (          bis.asm):00187         BIF_GT          equ             *-bis$base+CCS_REF_BIS_FIRST
7794 8D10             (          bis.asm):00188                                 bsr             cmp$int$args                                            ;compare arg1, arg2
7796 2EA5             (          bis.asm):00189                                 bgt             ret$true
7798 209F             (          bis.asm):00190                                 bra             ret$nil
                      (          bis.asm):00191         
     08B8             (          bis.asm):00192         BIF_LE          equ             *-bis$base+CCS_REF_BIS_FIRST
779A 8D0A             (          bis.asm):00193                                 bsr             cmp$int$args                                            ;compare arg1, arg2
779C 2F9F             (          bis.asm):00194                                 ble             ret$true
779E 2099             (          bis.asm):00195                                 bra             ret$nil
                      (          bis.asm):00196         
     08BE             (          bis.asm):00197         BIF_GE          equ             *-bis$base+CCS_REF_BIS_FIRST
77A0 8D04             (          bis.asm):00198                                 bsr             cmp$int$args                                            ;compare arg1, arg2
77A2 2C99             (          bis.asm):00199                                 bge             ret$true
77A4 2093             (          bis.asm):00200                                 bra             ret$nil
                      (          bis.asm):00201         
                      (          bis.asm):00202         ; >>> Compare two integer arguments
                      (          bis.asm):00203         ; PASSED:  X = list of args
                      (          bis.asm):00204         ; RETURNS: CC = compare arg1,arg2
77A6                  (          bis.asm):00205         cmp$int$args:
77A6 EC9802           (          bis.asm):00206                                 ldd             [CC_CDR_OFF,x]                                          ;D = arg2
77A9 8D0A             (          bis.asm):00207                                 bsr             int$sext                                                        ;sign extend to 16 bits
77AB 3406             (          bis.asm):00208                                 pshs    d
77AD 8D04             (          bis.asm):00209                                 bsr             int$arg                                                         ;D = arg1
77AF 10A3E1           (          bis.asm):00210                                 cmpd    ,s++                                                            ;set flags
77B2 39               (          bis.asm):00211                                 rts
                      (          bis.asm):00212         ;
77B3 EC84             (          bis.asm):00213         int$arg         ldd             CC_CAR_OFF,x                                            ;D = current arg
77B5 8540             (          bis.asm):00214         int$sext        bita    #$40                                                            ;negative?
77B7 2602             (          bis.asm):00215                                 bne             @ret                                                            ;yep, already sign extended
77B9 847F             (          bis.asm):00216                                 anda    #$7F                                                            ;else positive
77BB 39               (          bis.asm):00217         @ret            rts
                      (          bis.asm):00218         
                      (          bis.asm):00219         ;@@@ MATH
                      (          bis.asm):00220         
                      (          bis.asm):00221         ; >>> (+ e ...)
     08DA             (          bis.asm):00222         BIF_ADD         equ             *-bis$base+CCS_REF_BIS_FIRST
77BC 318D0015         (          bis.asm):00223                                 leay    @add,pcr                                                        ;Y = op
                      (          bis.asm):00224         ;
77C0 8DF1             (          bis.asm):00225         @op                     bsr             int$arg
77C2 3406             (          bis.asm):00226                                 pshs    d                                                                       ;,S = current value = arg1
77C4 AE02             (          bis.asm):00227         @lp                     ldx             CC_CDR_OFF,x                                            ;next arg
77C6 2706             (          bis.asm):00228                                 beq             @done                                                           ;if no more
77C8 8DE9             (          bis.asm):00229                                 bsr             int$arg                                                         ;D = arg
77CA ADA4             (          bis.asm):00230                                 jsr             ,y                                                                      ;update current with arg value
77CC 20F6             (          bis.asm):00231                                 bra             @lp
77CE 3506             (          bis.asm):00232         @done           puls    d
77D0 8A80             (          bis.asm):00233         ret$int         ora             #CCS_TYPE_INT/256
77D2 1F01             (          bis.asm):00234                                 tfr             d,x                                                                     ;X = final value
77D4 39               (          bis.asm):00235                                 rts
                      (          bis.asm):00236         ;
77D5 E362             (          bis.asm):00237         @add            addd    2,s                                                                     ;update sum
77D7 ED62             (          bis.asm):00238                                 std             2,s
77D9 39               (          bis.asm):00239                                 rts
                      (          bis.asm):00240         ;
                      (          bis.asm):00241         ; >>> (- e ...)
     08F8             (          bis.asm):00242         BIF_SUB         equ             *-bis$base+CCS_REF_BIS_FIRST
77DA 318D0002         (          bis.asm):00243                                 leay    @sub,pcr                                                        ;Y = op
77DE 20E0             (          bis.asm):00244                                 bra             @op
                      (          bis.asm):00245         ;
77E0 3406             (          bis.asm):00246         @sub            pshs    d                                                                       ;sure wish we had SUBD X|Y!
77E2 EC64             (          bis.asm):00247                                 ldd             4,s
77E4 A3E1             (          bis.asm):00248                                 subd    ,s++
77E6 ED62             (          bis.asm):00249                                 std             2,s
77E8 39               (          bis.asm):00250                                 rts
                      (          bis.asm):00251         ;
                      (          bis.asm):00252         ; >>> (MIN e ...)
     0907             (          bis.asm):00253         BIF_MIN         equ             *-bis$base+CCS_REF_BIS_FIRST
77E9 318D0002         (          bis.asm):00254                                 leay    @min,pcr                                                        ;Y = op
77ED 20D1             (          bis.asm):00255                                 bra             @op
                      (          bis.asm):00256         ;
77EF 10A362           (          bis.asm):00257         @min            cmpd    2,s
77F2 2C02             (          bis.asm):00258                                 bge             @ret                                                            ;if arg >= cur
77F4 ED62             (          bis.asm):00259         @upd            std             2,s                                                                     ;else update cur
77F6 39               (          bis.asm):00260         @ret            rts
                      (          bis.asm):00261         ;
                      (          bis.asm):00262         ; >>> (MAX e ...)
     0915             (          bis.asm):00263         BIF_MAX         equ             *-bis$base+CCS_REF_BIS_FIRST
77F7 318D0002         (          bis.asm):00264                                 leay    @max,pcr                                                        ;Y = op
77FB 20C3             (          bis.asm):00265                                 bra             @op
                      (          bis.asm):00266         ;
77FD 10A362           (          bis.asm):00267         @max            cmpd    2,s
7800 2EF2             (          bis.asm):00268                                 bgt             @upd                                                            ;if arg > cur
7802 39               (          bis.asm):00269                                 rts
                      (          bis.asm):00270         ;
                      (          bis.asm):00271         ; >>> (| e ...) - bitwise OR
     0921             (          bis.asm):00272         BIF_BIT_OR      equ             *-bis$base+CCS_REF_BIS_FIRST
7803 318D0002         (          bis.asm):00273                                 leay    @or,pcr
7807 20B7             (          bis.asm):00274                                 bra             @op
                      (          bis.asm):00275         ;
7809 AA62             (          bis.asm):00276         @or                     ora             2,s
780B EA63             (          bis.asm):00277                                 orb             3,s
780D 20E5             (          bis.asm):00278                                 bra             @upd
                      (          bis.asm):00279         ;
                      (          bis.asm):00280         ; >>> (& e ...) - bitwise AND
     092D             (          bis.asm):00281         BIF_BIT_AND     equ             *-bis$base+CCS_REF_BIS_FIRST
780F 318D0002         (          bis.asm):00282                                 leay    @and,pcr
7813 20AB             (          bis.asm):00283                                 bra             @op
                      (          bis.asm):00284         ;
7815 A462             (          bis.asm):00285         @and            anda    2,s
7817 E463             (          bis.asm):00286                                 andb    3,s
7819 20D9             (          bis.asm):00287                                 bra             @upd
                      (          bis.asm):00288         ;
                      (          bis.asm):00289         ; >>> (^ e ...) - bitwise XOR
     0939             (          bis.asm):00290         BIF_BIT_XOR     equ             *-bis$base+CCS_REF_BIS_FIRST
781B 318D0002         (          bis.asm):00291                                 leay    @xor,pcr
781F 209F             (          bis.asm):00292                                 bra             @op
                      (          bis.asm):00293         ;
7821 A862             (          bis.asm):00294         @xor            eora    2,s
7823 E863             (          bis.asm):00295                                 eorb    3,s
7825 20CD             (          bis.asm):00296                                 bra             @upd
                      (          bis.asm):00297         
                      (          bis.asm):00298         ; >>> (* e1 e2)
     0945             (          bis.asm):00299         BIF_MUL         equ             *-bis$base+CCS_REF_BIS_FIRST
7827 108E79C6         (          bis.asm):00300                                 ldy             #mul16
                      (          bis.asm):00301         ;
782B 6FE2             (          bis.asm):00302         @op2            clr             ,-s                                                                     ;,S = final sign
782D EC84             (          bis.asm):00303                                 ldd             CC_CAR_OFF,x                                            ;D = arg1
782F 8D15             (          bis.asm):00304                                 bsr             @norm                                                           ;normalize to positive number
7831 3606             (          bis.asm):00305                                 pshu    d
7833 EC9802           (          bis.asm):00306                                 ldd             [CC_CDR_OFF,x]                                          ;D = arg2
7836 8D0E             (          bis.asm):00307                                 bsr             @norm
7838 1F01             (          bis.asm):00308                                 tfr             d,x
783A 3706             (          bis.asm):00309                                 pulu    d
783C ADA4             (          bis.asm):00310                                 jsr             ,y                                                                      ;perform the operation
783E 66E0             (          bis.asm):00311                                 ror             ,s+
7840 248E             (          bis.asm):00312                                 bcc             ret$int                                                         ;if result should be positive
7842 8D0B             (          bis.asm):00313                                 bsr             @negd
7844 208A             (          bis.asm):00314                                 bra             ret$int
                      (          bis.asm):00315         ;
7846 8540             (          bis.asm):00316         @norm           bita    #(CCS_INT_MASK-(CCS_INT_MASK/2))/256
7848 2603             (          bis.asm):00317                                 bne             @neg                                                            ;if it's a negative number
784A 847F             (          bis.asm):00318                                 anda    #CCS_INT_MASK/256                                       ;else strip type
784C 39               (          bis.asm):00319                                 rts                                                                                     ;and return positive number
784D 6C62             (          bis.asm):00320         @neg            inc             2,s                                                                     ;negative number, flip result sign
784F 43               (          bis.asm):00321         @negd           coma                                                                            ;and negate number
7850 53               (          bis.asm):00322                                 comb
7851 C30001           (          bis.asm):00323                                 addd    #1
7854 39               (          bis.asm):00324                                 rts
                      (          bis.asm):00325         ;
                      (          bis.asm):00326         ; >>> (/ e1 e2)
     0973             (          bis.asm):00327         BIF_DIV         equ             *-bis$base+CCS_REF_BIS_FIRST
7855 108E79E4         (          bis.asm):00328                                 ldy             #div16                                                          ;Y = op
7859 20D0             (          bis.asm):00329                                 bra             @op2
                      (          bis.asm):00330         ;
                      (          bis.asm):00331         ; >>> (MOD e1 e2)
     0979             (          bis.asm):00332         BIF_REM         equ             *-bis$base+CCS_REF_BIS_FIRST
785B 108E79E9         (          bis.asm):00333                                 ldy             #mod16                                                          ;Y = op
785F 20CA             (          bis.asm):00334                                 bra             @op2
                      (          bis.asm):00335         
                      (          bis.asm):00336         ; >>> (READ)
     097F             (          bis.asm):00337         BIF_READ        equ             *-bis$base+CCS_REF_BIS_FIRST
7861 7E732B           (          bis.asm):00338                                 jmp             read
                      (          bis.asm):00339         
                      (          bis.asm):00340         ; >>> (EVAL e)
     0982             (          bis.asm):00341         BIF_EVAL        equ             *-bis$base+CCS_REF_BIS_FIRST
7864 AE84             (          bis.asm):00342                                 ldx             CC_CAR_OFF,x                                            ;first argument
7866 7E73B9           (          bis.asm):00343                                 jmp             eval
                      (          bis.asm):00344         
                      (          bis.asm):00345         ; >>> (PRINT e)
     0987             (          bis.asm):00346         BIF_PRINT       equ             *-bis$base+CCS_REF_BIS_FIRST
7869 AE84             (          bis.asm):00347         bif$print       ldx             CC_CAR_OFF,x                                            ;first argument
786B 3610             (          bis.asm):00348                                 pshu    x
786D BD757D           (          bis.asm):00349                                 jsr             print
7870 3710             (          bis.asm):00350                                 pulu    x
7872 39               (          bis.asm):00351                                 rts
                      (          bis.asm):00352         
                      (          bis.asm):00353         ; >>> (PRINTLN e)
     0991             (          bis.asm):00354         BIF_PRINTLN     equ             *-bis$base+CCS_REF_BIS_FIRST
7873 8DF4             (          bis.asm):00355                                 bsr             bif$print
7875 8D01             (          bis.asm):00356                                 bsr             bif$nl
7877 39               (          bis.asm):00357                                 rts
                      (          bis.asm):00358         
                      (          bis.asm):00359         ; >>> (NL)
     0996             (          bis.asm):00360         BIF_NL          equ             *-bis$base+CCS_REF_BIS_FIRST
7878 7E7AAB           (          bis.asm):00361         bif$nl          jmp             con$nl
                      (          bis.asm):00362         
                      (          bis.asm):00363         ; >>> (SET v e)
     0999             (          bis.asm):00364         BIF_SET         equ             *-bis$base+CCS_REF_BIS_FIRST
787B 10AE84           (          bis.asm):00365                                 ldy             CC_CAR_OFF,x
787E AE9802           (          bis.asm):00366                                 ldx             [CC_CDR_OFF,x]
7881 1E12             (          bis.asm):00367                                 exg             x,y                                                                     ;X = v, Y = e
7883 BD7541           (          bis.asm):00368                                 jsr             env$get$atom$binding                            ;X = CONS w/binding
7886 10AF02           (          bis.asm):00369                                 sty             CC_CDR_OFF,x                                            ;update to new value
7889 1F21             (          bis.asm):00370                                 tfr             y,x                                                                     ;return expression
788B 39               (          bis.asm):00371                                 rts
                      (          bis.asm):00372         
                      (          bis.asm):00373         ; >>> (LOAD)
     09AA             (          bis.asm):00374         BIF_LOAD        equ             *-bis$base+CCS_REF_BIS_FIRST
788C 7E7A08           (          bis.asm):00375                                 jmp             con$load
                      (          bis.asm):00376         
                      (          bis.asm):00377         ; >>> (LOADED)
     09AD             (          bis.asm):00378         BIF_LOADED      equ             *-bis$base+CCS_REF_BIS_FIRST
788F 7E7A0F           (          bis.asm):00379                                 jmp             con$loaded
                      (          bis.asm):00380         
                      (          bis.asm):00381         ; >>> (RETURN e) - only valid within a (PROG)
     09B0             (          bis.asm):00382         BIF_RETURN      equ             *-bis$base+CCS_REF_BIS_FIRST
7892 3610             (          bis.asm):00383                                 pshu    x                                                                       ;allocate a ret entry (ret.<value>)
7894 BD7609           (          bis.asm):00384                                 jsr             cons$alloc
7897 CC000E           (          bis.asm):00385                                 ldd             #ATOM_ret
789A ED84             (          bis.asm):00386                                 std             CC_CAR_OFF,x
789C 3720             (          bis.asm):00387                                 pulu    y
789E ECA4             (          bis.asm):00388                                 ldd             CC_CAR_OFF,y
78A0 ED02             (          bis.asm):00389                                 std             CC_CDR_OFF,x
78A2 1F10             (          bis.asm):00390                                 tfr             x,d                                                                     ;D = the ret entry
                      (          bis.asm):00391         ;
78A4 BD79AD           (          bis.asm):00392                                 jsr             prg$find$first                                          ;Y = addr of first 'prg' entry on U stack
78A7 ED3C             (          bis.asm):00393                                 std             -4,y                                                            ;overwrite current expr with ret entry
78A9 39               (          bis.asm):00394                                 rts
                      (          bis.asm):00395         
                      (          bis.asm):00396         ; >>> (DEF v e)
     09C8             (          bis.asm):00397         BIF_DEF         equ             *-bis$base+CCS_REF_BIS_FIRST
78AA EC84             (          bis.asm):00398                                 ldd             CC_CAR_OFF,x                                            ;Y = v
78AC AE9802           (          bis.asm):00399                                 ldx             [CC_CDR_OFF,x]                                          ;X = e
78AF 3610             (          bis.asm):00400                                 pshu    x
78B1 109E08           (          bis.asm):00401                                 ldy             <env_globals                                            ;always defines in global env
78B4 BD750E           (          bis.asm):00402                                 jsr             env$def$in                                                      ;go define it
78B7 3710             (          bis.asm):00403                                 pulu    x                                                                       ;return e
78B9 39               (          bis.asm):00404                                 rts
                      (          bis.asm):00405         
     78BA             (          bis.asm):00406         bif$end         equ             *
                      (          bis.asm):00407         ;
     080D             (          bis.asm):00408         CCS_REF_BIF_FIRST       equ             bif$base-bis$base+CCS_REF_BIS_FIRST
     09D8             (          bis.asm):00409         CCS_REF_BIF_END         equ             bif$end-bis$base+CCS_REF_BIS_FIRST
                      (          bis.asm):00410         
                      (          bis.asm):00411         ;@@@
                      (          bis.asm):00412         ;@@@ BUILT-IN QUOTED FUNCTIONS (X = UNEVALUATED ARGS)
                      (          bis.asm):00413         ;@@@
     78BA             (          bis.asm):00414         biq$base        equ             *
                      (          bis.asm):00415         
                      (          bis.asm):00416         ; >>> (LET (vars) (expr))
     09D8             (          bis.asm):00417         BIQ_LET         equ             *-bis$base+CCS_REF_BIS_FIRST
78BA 10AE84           (          bis.asm):00418                                 ldy             CC_CAR_OFF,x                                            ;Y = list of vars
78BD EC9802           (          bis.asm):00419                                 ldd             [CC_CDR_OFF,x]                                          ;D = expression
78C0 3606             (          bis.asm):00420                                 pshu    d
78C2 8E0000           (          bis.asm):00421                                 ldx             #ATOM_NIL                                                       ;X = values (all NIL)
78C5 BD7497           (          bis.asm):00422                                 jsr             eval$apply$args                                         ;create an ENV
78C8 3716             (          bis.asm):00423                                 pulu    d,x
78CA 3606             (          bis.asm):00424                                 pshu    d                                                                       ;evaluate the expr
78CC BD73B9           (          bis.asm):00425                                 jsr             eval
78CF 3342             (          bis.asm):00426                                 leau    2,u                                                                     ;drop ENV
78D1 39               (          bis.asm):00427                                 rts
                      (          bis.asm):00428         
                      (          bis.asm):00429         ; >>> (SETQ v e)
     09F0             (          bis.asm):00430         BIQ_SETQ        equ             *-bis$base+CCS_REF_BIS_FIRST
78D2 10AE84           (          bis.asm):00431                                 ldy             CC_CAR_OFF,x                                            ;Y = v
78D5 AE9802           (          bis.asm):00432                                 ldx             [CC_CDR_OFF,x]                                          ;X = e
78D8 3420             (          bis.asm):00433                                 pshs    y
78DA BD73B9           (          bis.asm):00434                                 jsr             eval                                                            ;X = (EVAL e)
78DD 3520             (          bis.asm):00435                                 puls    y
78DF 1E12             (          bis.asm):00436                                 exg             x,y                                                                     ;X = v, Y = e
78E1 BD7541           (          bis.asm):00437                                 jsr             env$get$atom$binding                            ;X = CONS w/binding
78E4 10AF02           (          bis.asm):00438                                 sty             CC_CDR_OFF,x                                            ;update to new value
78E7 1F21             (          bis.asm):00439                                 tfr             y,x                                                                     ;return expression
78E9 39               (          bis.asm):00440                                 rts
                      (          bis.asm):00441         
                      (          bis.asm):00442         ; >>> (GC) - run garbage collection
     0A08             (          bis.asm):00443         BIQ_GC          equ             *-bis$base+CCS_REF_BIS_FIRST
78EA BD7653           (          bis.asm):00444                                 jsr             gc$run                                                          ;collect the garbage
78ED 7E7643           (          bis.asm):00445                                 jmp             gc$free                                                         ;return free space
                      (          bis.asm):00446         
                      (          bis.asm):00447         ; >>> (COND (p e) ...)
     0A0E             (          bis.asm):00448         BIQ_COND        equ             *-bis$base+CCS_REF_BIS_FIRST
78F0 8C0000           (          bis.asm):00449         @lp                     cmpx    #ATOM_NIL
78F3 2721             (          bis.asm):00450                                 beq             @ret                                                            ;if end of list return NIL
78F5 10AE84           (          bis.asm):00451                                 ldy             CC_CAR_OFF,x                                            ;Y = next pred, expr pair
78F8 AE02             (          bis.asm):00452                                 ldx             CC_CDR_OFF,x
78FA 3610             (          bis.asm):00453                                 pshu    x
78FC AEA4             (          bis.asm):00454                                 ldx             CC_CAR_OFF,y                                            ;X = predicate
78FE 3620             (          bis.asm):00455                                 pshu    y                                                                       ;evaluate predicate
7900 BD73B9           (          bis.asm):00456                                 jsr             eval
7903 3720             (          bis.asm):00457                                 pulu    y
7905 8C0000           (          bis.asm):00458                                 cmpx    #ATOM_NIL
7908 2604             (          bis.asm):00459                                 bne             @true                                                           ;if value was true (non-NIL)
790A 3710             (          bis.asm):00460                                 pulu    x                                                                       ;else next pair
790C 20E2             (          bis.asm):00461                                 bra             @lp
                      (          bis.asm):00462         ;
790E 3342             (          bis.asm):00463         @true           leau    2,u                                                                     ;drop remaining pairs
7910 AEB802           (          bis.asm):00464                                 ldx             [CC_CDR_OFF,y]                                          ;X = expression
7913 7E73B9           (          bis.asm):00465                                 jmp             eval                                                            ;return it's value
7916 39               (          bis.asm):00466         @ret            rts
                      (          bis.asm):00467         
                      (          bis.asm):00468         ; >>> (AND e ..) - assumes at least one arg
     0A35             (          bis.asm):00469         BIQ_AND         equ             *-bis$base+CCS_REF_BIS_FIRST
7917 3610             (          bis.asm):00470         @andlp          pshu    x                                                                       ;eval next arg
7919 AE84             (          bis.asm):00471                                 ldx             CC_CAR_OFF,x
791B BD73B9           (          bis.asm):00472                                 jsr             eval
791E 1F12             (          bis.asm):00473                                 tfr             x,y                                                                     ;Y = last arg value
7920 3710             (          bis.asm):00474                                 pulu    x
7922 108C0000         (          bis.asm):00475                                 cmpy    #ATOM_NIL
7926 2704             (          bis.asm):00476                                 beq             @done                                                           ;value is NIL so return NIL
7928 AE02             (          bis.asm):00477                                 ldx             CC_CDR_OFF,x
792A 26EB             (          bis.asm):00478                                 bne             @andlp                                                          ;next arg (if there is one)
                      (          bis.asm):00479         ;
792C 1F21             (          bis.asm):00480         @done           tfr             y,x                                                                     ;return last value
792E 39               (          bis.asm):00481                                 rts                     
                      (          bis.asm):00482         
                      (          bis.asm):00483         ; >>> (OR e ..) - assumes at least one arg
     0A4D             (          bis.asm):00484         BIQ_OR          equ             *-bis$base+CCS_REF_BIS_FIRST
792F 3610             (          bis.asm):00485         @orlp           pshu    x                                                                       ;eval next arg
7931 AE84             (          bis.asm):00486                                 ldx             CC_CAR_OFF,x
7933 BD73B9           (          bis.asm):00487                                 jsr             eval
7936 3720             (          bis.asm):00488                                 pulu    y
7938 8C0000           (          bis.asm):00489                                 cmpx    #ATOM_NIL
793B 2604             (          bis.asm):00490                                 bne             @done                                                           ;return it if non-NIL
793D AE22             (          bis.asm):00491                                 ldx             CC_CDR_OFF,y
793F 26EE             (          bis.asm):00492                                 bne             @orlp                                                           ;handle next arg if any (else return NIL)
7941 39               (          bis.asm):00493         @done           rts                                                                                     ;X = return value
                      (          bis.asm):00494         
                      (          bis.asm):00495         ; >>> (PROG (vars) e ...)
     0A60             (          bis.asm):00496         BIQ_PROG        equ             *-bis$base+CCS_REF_BIS_FIRST
7942 3610             (          bis.asm):00497                                 pshu    x                                                                       ;4,U = PROG list
7944 10AE84           (          bis.asm):00498                                 ldy             CC_CAR_OFF,x                                            ;Y = vars list
7947 8E0000           (          bis.asm):00499                                 ldx             #ATOM_NIL
794A BD7497           (          bis.asm):00500                                 jsr             eval$apply$args                                         ;2,U = our vars 'env'
794D CC000A           (          bis.asm):00501                                 ldd             #ATOM_prg                                                       ;allocate our 'prg' frame
7950 BD7600           (          bis.asm):00502                                 jsr             cons$alloc$tag
7953 10AE42           (          bis.asm):00503                                 ldy             2,u
7956 10AE22           (          bis.asm):00504                                 ldy             CC_CDR_OFF,y                                            ;PROG expr list
7959 10AF02           (          bis.asm):00505                                 sty             CC_CDR_OFF,x                                            ;append to 'prg' frame
795C AF42             (          bis.asm):00506                                 stx             2,u                                                                     ;4,U = our 'prg' frame
795E 3620             (          bis.asm):00507                                 pshu    y                                                                       ;,U = current expr in PROG list
                      (          bis.asm):00508         ;
7960 AEC4             (          bis.asm):00509         @lp                     ldx             ,u                                                                      ;eval next expr
7962 271B             (          bis.asm):00510                                 beq             @done                                                           ;or return NIL if end
7964 10AE02           (          bis.asm):00511                                 ldy             CC_CDR_OFF,x                                            ;Y = next expr (or RETURN value)
                      (          bis.asm):00512         ;
7967 EC84             (          bis.asm):00513                                 ldd             CC_CAR_OFF,x                                            ;was a (RETURN e) executed?
7969 1083000E         (          bis.asm):00514                                 cmpd    #ATOM_ret
796D 270E             (          bis.asm):00515                                 beq             @ret                                                            ;yep, we're done
                      (          bis.asm):00516         ;
796F 10AFC4           (          bis.asm):00517                                 sty             ,u                                                                      ;else update next expr
7972 10830800         (          bis.asm):00518                                 cmpd    #CCS_REF_ATOM_END
7976 25E8             (          bis.asm):00519                                 blo             @lp                                                                     ;skip ATOMs (labels)
7978 BD73B9           (          bis.asm):00520                                 jsr             eval                                                            ;eval this expr
797B 20E3             (          bis.asm):00521                                 bra             @lp                                                                     ;and check next
                      (          bis.asm):00522         ;
797D 1F21             (          bis.asm):00523         @ret            tfr             y,x                                                                     ;X = RETURN value
797F 3346             (          bis.asm):00524         @done           leau    6,u                                                                     ;clean up the root stack
7981 39               (          bis.asm):00525                                 rts
                      (          bis.asm):00526         
                      (          bis.asm):00527         ; >>> (GO label)
     0AA0             (          bis.asm):00528         BIQ_GO          equ             *-bis$base+CCS_REF_BIS_FIRST
7982 EC84             (          bis.asm):00529                                 ldd             CC_CAR_OFF,x                                            ;D = label to find
                      (          bis.asm):00530         ;
7984 8D27             (          bis.asm):00531                                 bsr             prg$find$first                                          ;Y = addr of ptr to first 'prg' frame
7986 2617             (          bis.asm):00532         @prglp          bne             @bail                                                           ;if none found
7988 AEA4             (          bis.asm):00533                                 ldx             ,y                                                                      ;X = the 'prg' frame (prg e e ...)
                      (          bis.asm):00534         ;
798A AE02             (          bis.asm):00535         @labellp        ldx             CC_CDR_OFF,x                                            ;X = next item in PROG list
798C 270D             (          bis.asm):00536                                 beq             @prgnext                                                        ;if end of list
798E 10A384           (          bis.asm):00537                                 cmpd    CC_CAR_OFF,x
7991 26F7             (          bis.asm):00538                                 bne             @labellp                                                        ;if it's not our label
                      (          bis.asm):00539         ;
7993 AE02             (          bis.asm):00540                                 ldx             CC_CDR_OFF,x                                            ;X = expr after label
7995 AF3C             (          bis.asm):00541                                 stx             -4,y                                                            ;update the 'prg' frame's next expr
7997 8E0000           (          bis.asm):00542                                 ldx             #ATOM_NIL                                                       ;return NIL
799A 39               (          bis.asm):00543                                 rts
                      (          bis.asm):00544         ;
799B 8D20             (          bis.asm):00545         @prgnext        bsr             prg$find$next                                           ;find next 'prg' frame
799D 20E7             (          bis.asm):00546                                 bra             @prglp
                      (          bis.asm):00547         ;
799F 1F01             (          bis.asm):00548         @bail           tfr             d,x                                                                     ;label we couldn't find
79A1 BD707D           (          bis.asm):00549                                 jsr             bail$ref
79A4 0843616E27742047 (          bis.asm):00550                                 fcb             8,'C','a','n',SQUOT,'t',' ','G','O'
     4F
                      (          bis.asm):00551         
     79AD             (          bis.asm):00552         biq$end         equ             *
                      (          bis.asm):00553         ;
     09D8             (          bis.asm):00554         CCS_REF_BIQ_FIRST       equ             biq$base-bis$base+CCS_REF_BIS_FIRST
     0ACB             (          bis.asm):00555         CCS_REF_BIQ_END         equ             biq$end-bis$base+CCS_REF_BIS_FIRST
                      (          bis.asm):00556         
                      (          bis.asm):00557         ;@@@
                      (          bis.asm):00558         ;@@@ END OF BUILT-INS
                      (          bis.asm):00559         ;@@@
     79AD             (          bis.asm):00560         bis$end         equ             *
                      (          bis.asm):00561         
                      (          bis.asm):00562                 IFGT (bis$end-bis$base-VARS_SIZE)
                      (          bis.asm):00563                 ERROR "BUILT-INS BIGGER THAN VARS_SIZE!"
                      (          bis.asm):00564                 ENDIF
                      (          bis.asm):00565         
                      (          bis.asm):00566         ;@@@
                      (          bis.asm):00567         ;@@@ BUILT-INS SUPPORT
                      (          bis.asm):00568         ;@@@
                      (          bis.asm):00569         
                      (          bis.asm):00570         ; >>> Find first/next 'prg' frame on the root stack (U)
                      (          bis.asm):00571         ; PASSED:  Y = last found 'prg' frame (next only)
                      (          bis.asm):00572         ; RETURNS: EQ, Y = addr of 'prg' frame on the U stack else NE
                      (          bis.asm):00573         ; DOES NOT ALTER D
                      (          bis.asm):00574         ; NOTE: $next is only valid if no CONS allocs happened after the $first
79AD                  (          bis.asm):00575         prg$find$first:
79AD 1F32             (          bis.asm):00576                                 tfr             u,y                                                                     ;start with top of U stack
79AF AEA4             (          bis.asm):00577         @lp                     ldx             ,y
79B1 BD75EA           (          bis.asm):00578                                 jsr             ref$is$cons
79B4 2607             (          bis.asm):00579                                 bne             prg$find$next                                           ;if it's not a CONS
79B6 AE84             (          bis.asm):00580                                 ldx             CC_CAR_OFF,x
79B8 8C000A           (          bis.asm):00581                                 cmpx    #ATOM_prg
79BB 2708             (          bis.asm):00582                                 beq             @ret                                                            ;if found a 'prg'
79BD                  (          bis.asm):00583         prg$find$next:
79BD 3122             (          bis.asm):00584                                 leay    2,y                                                                     ;advance to next U stack entry
79BF 108C13FF         (          bis.asm):00585                                 cmpy    #ROOT_STACK_TOP-1
79C3 25EA             (          bis.asm):00586                                 blo             @lp                                                                     ;if not top of U stack
79C5 39               (          bis.asm):00587         @ret            rts
                      (    ./src/syl.asm):00358                         include "misc.asm"
                      (         misc.asm):00001         ; "misc.asm" - miscellaneous routines
                      (         misc.asm):00002         ; 2023-feb-19 dww  created
                      (         misc.asm):00003         
                      (         misc.asm):00004         
                      (         misc.asm):00005         ; ==> 16 bit multiplication
                      (         misc.asm):00006         ; PASSED:  D = multiplicand, X = multiplier
                      (         misc.asm):00007         ; RETURNS: D = X = low 16 bits of product
79C6 3416             (         misc.asm):00008         mul16:  pshs    d,x
79C8 1F18             (         misc.asm):00009                         tfr             x,a
79CA 3D               (         misc.asm):00010                         mul
79CB 1E01             (         misc.asm):00011                         exg             d,x
79CD E661             (         misc.asm):00012                         ldb             1,s
79CF 3D               (         misc.asm):00013                         mul
79D0 1F98             (         misc.asm):00014                         tfr             b,a
79D2 5F               (         misc.asm):00015                         clrb
79D3 308B             (         misc.asm):00016                         leax    d,x
79D5 E6E4             (         misc.asm):00017                         ldb             ,s
79D7 A663             (         misc.asm):00018                         lda             3,s
79D9 3D               (         misc.asm):00019                         mul
79DA 1F98             (         misc.asm):00020                         tfr             b,a
79DC 5F               (         misc.asm):00021                         clrb
79DD 308B             (         misc.asm):00022                         leax    d,x
79DF 1F10             (         misc.asm):00023                         tfr             x,d
79E1 3264             (         misc.asm):00024                         leas    4,s
79E3 39               (         misc.asm):00025                         rts
                      (         misc.asm):00026         
                      (         misc.asm):00027         ; ==> 16 bit division
                      (         misc.asm):00028         ; PASSED:  D = dividend, X = divisor
                      (         misc.asm):00029         ; RETURNS: D = quotient, X = remainder
79E4 8D03             (         misc.asm):00030         div16:  bsr             mod16
79E6 1E01             (         misc.asm):00031                         exg             d,x
79E8 39               (         misc.asm):00032                         rts
                      (         misc.asm):00033         
                      (         misc.asm):00034         ; ==> 16 Bit modulo
                      (         misc.asm):00035         ; PASSED:  D = dividend, X = divisor
                      (         misc.asm):00036         ; RETURNS: D = remainder, X = quotient
79E9 3416             (         misc.asm):00037         mod16:  pshs    x,d                                                                                             ;0,s = dividend, 2,s = divisor
79EB 4F               (         misc.asm):00038                         clra                                                                                                    ;D = accumulator (inited to 0)
79EC 5F               (         misc.asm):00039                         clrb
                      (         misc.asm):00040         ;
79ED 8E0010           (         misc.asm):00041                         ldx             #16
79F0 6861             (         misc.asm):00042         @lp             lsl             1,s                                                                                             ; acc,dividend <<= 1
79F2 6960             (         misc.asm):00043                         rol             0,s
79F4 59               (         misc.asm):00044                         rolb
79F5 49               (         misc.asm):00045                         rola
79F6 10A362           (         misc.asm):00046                         cmpd    2,s
79F9 2504             (         misc.asm):00047                         blo             @nxt                                                                                    ;if next result bit is 0
79FB A362             (         misc.asm):00048                         subd    2,s                                                                                             ;else actually subtract it
79FD 6C61             (         misc.asm):00049                         inc             1,s                                                                                             ;and set result bit
79FF 301F             (         misc.asm):00050         @nxt    leax    -1,x
7A01 26ED             (         misc.asm):00051                         bne             @lp                                                                                             ;if not done yet
                      (         misc.asm):00052         ;
7A03 3510             (         misc.asm):00053                         puls    x                                                                                               ;D = remainder, X = quotient
7A05 3262             (         misc.asm):00054                         leas    2,s
7A07 39               (         misc.asm):00055                         rts
                      (    ./src/syl.asm):00359                         include "con.asm"
                      (          con.asm):00001         ; "con.asm" - console support for Syl
                      (          con.asm):00002         ; 2023-feb-06 dww  created
                      (          con.asm):00003         
                      (          con.asm):00004         ;@@@
                      (          con.asm):00005         ;@@@ CONSOLE INPUT
                      (          con.asm):00006         ;@@@
                      (          con.asm):00007         
                      (          con.asm):00008         ; >>> Start loading from console
7A08 8601             (          con.asm):00009         con$load        lda             #1
7A0A 9763             (          con.asm):00010                                 sta             <con_loading                                                    ;set flag
7A0C 7E7B59           (          con.asm):00011                                 jmp             con$pause                                                               ;pause input until next line input
                      (          con.asm):00012         
                      (          con.asm):00013         ; >>> Stop loading from console
7A0F 0D63             (          con.asm):00014         con$loaded      tst             <con_loading                                                    ;were we loading?
7A11 270B             (          con.asm):00015                                 beq             @ret                                                                    ;nope
7A13 0F63             (          con.asm):00016                                 clr             <con_loading                                                    ;not any more
7A15 7E7B5F           (          con.asm):00017                                 jmp             con$resume
                      (          con.asm):00018         ;
                      (          con.asm):00019         ; >>> Get next non-blank character (skips SPACES, TABs, NLs, etc)
7A18 8D05             (          con.asm):00020         con$getnb       bsr             con$getc
7A1A C120             (          con.asm):00021                                 cmpb    #$20
7A1C 23FA             (          con.asm):00022                                 bls             con$getnb                                                               ;skip whitespace chars
7A1E 39               (          con.asm):00023         @ret            rts
                      (          con.asm):00024         
                      (          con.asm):00025         ; >>> Read next buffered input character
                      (          con.asm):00026         ; RETURNS: B = char, will be NL at end of line
                      (          con.asm):00027         ; ALTERS NO OTHER REGISTERS!
7A1F 3412             (          con.asm):00028         con$getc        pshs    x,a
7A21 9E11             (          con.asm):00029         @getc           ldx             <con_buf_next                                                   ;offset for next char
7A23 2B18             (          con.asm):00030                                 bmi             @getl                                                                   ;if need to fill it
7A25 9C0F             (          con.asm):00031                                 cmpx    <con_buf_len
7A27 240B             (          con.asm):00032                                 bhs             @eol                                                                    ;if hit end of line
7A29 E6890813         (          con.asm):00033                                 ldb             con_buf,x                                                               ;B = next char
7A2D 3001             (          con.asm):00034                                 leax    1,x                                                                             ;bump to next
7A2F 9F11             (          con.asm):00035         @gotc           stx             <con_buf_next
7A31 3512             (          con.asm):00036                                 puls    x,a
7A33 39               (          con.asm):00037                                 rts
                      (          con.asm):00038         ;
7A34 C60A             (          con.asm):00039         @eol            ldb             #NL                                                                             ;return newline at end of line
7A36 8EFFFF           (          con.asm):00040                                 ldx             #CON_BUF_EMPTY                                                  ;and set flag to refill buffer
7A39 9F0A             (          con.asm):00041                                 stx             <lex$tok$start                                                  ;also invalidate last token
7A3B 20F2             (          con.asm):00042                                 bra             @gotc
                      (          con.asm):00043         ;
7A3D 8D1C             (          con.asm):00044         @getl           bsr             con$getl                                                                ;get next line of input
7A3F 20E0             (          con.asm):00045                                 bra             @getc                                                                   ;and try again
                      (          con.asm):00046         
                      (          con.asm):00047         ; >>> Undo last con$getc (if possible)
                      (          con.asm):00048         ; ALTERS NO REGISTERS
7A41 3406             (          con.asm):00049         con$ungetc      pshs    d
7A43 DC11             (          con.asm):00050                                 ldd             <con_buf_next
7A45 2707             (          con.asm):00051                                 beq             @done                                                                   ;can't undo past start of buffer
7A47 2D08             (          con.asm):00052                                 blt             @end                                                                    ;if empty then go back to end
7A49 830001           (          con.asm):00053                                 subd    #1                                                                              ;else backup one char
7A4C DD11             (          con.asm):00054                                 std             <con_buf_next
7A4E 3506             (          con.asm):00055         @done           puls    d
7A50 39               (          con.asm):00056                                 rts
                      (          con.asm):00057         ;
7A51 DC0F             (          con.asm):00058         @end            ldd             <con_buf_len
7A53 20F9             (          con.asm):00059                                 bra             @done
                      (          con.asm):00060         
                      (          con.asm):00061         ; >>> Cancel remaining chars in input buffer
7A55 CCFFFF           (          con.asm):00062         con$canl        ldd             #CON_BUF_EMPTY
7A58 DD11             (          con.asm):00063                                 std             <con_buf_next
7A5A 39               (          con.asm):00064                                 rts
                      (          con.asm):00065         
                      (          con.asm):00066         ; >>> Read a line of input to the buffer
                      (          con.asm):00067         ; ALTERS:  B,X
7A5B 0D63             (          con.asm):00068         con$getl        tst             <con_loading
7A5D 2703             (          con.asm):00069                                 beq             @prep                                                                   ;if not loading from console
7A5F BD7B5F           (          con.asm):00070                                 jsr             con$resume                                                              ;else resume input
                      (          con.asm):00071         ;
7A62 8D5F             (          con.asm):00072         @prep           bsr             con$prompt                                                              ;display prompt if needed
7A64 8E0000           (          con.asm):00073                                 ldx             #0                                                                              ;offset to start of buffer
7A67 9F11             (          con.asm):00074                                 stx             <con_buf_next                                                   ;will be next input char
                      (          con.asm):00075         ;
7A69 1700E2           (          con.asm):00076         @lp                     lbsr    con$gotc                                                                ;wait for next input char
7A6C 27FB             (          con.asm):00077                                 beq             @lp
7A6E C120             (          con.asm):00078                                 cmpb    #$20
7A70 2513             (          con.asm):00079                                 blo             @ctl                                                                    ;if it's a control char
7A72 C17E             (          con.asm):00080                                 cmpb    #$7E
7A74 22F3             (          con.asm):00081                                 bhi             @lp                                                                             ;ignore non-printables (?)
                      (          con.asm):00082         ;
7A76 8C0050           (          con.asm):00083                                 cmpx    #CON_BUF_SIZE                                                   ;is there room?
7A79 24EE             (          con.asm):00084                                 bhs             @lp                                                                             ;nope, ignore it
7A7B E7890813         (          con.asm):00085                                 stb             con_buf,x                                                               ;store it
7A7F 3001             (          con.asm):00086                                 leax    1,x                                                                             ;and advance count
7A81 8D30             (          con.asm):00087         @echo           bsr             con$putc                                                                ;echo it
7A83 20E4             (          con.asm):00088                                 bra             @lp                                                                             ;try for another
                      (          con.asm):00089         ;
7A85 C108             (          con.asm):00090         @ctl            cmpb    #BS
7A87 2611             (          con.asm):00091                                 bne             @eol?                                                                   ;if not backspace
7A89 8C0000           (          con.asm):00092                                 cmpx    #0
7A8C 27DB             (          con.asm):00093                                 beq             @lp                                                                             ;if at start of line
7A8E 301F             (          con.asm):00094                                 leax    -1,x                                                                    ;drop last char
7A90 8D21             (          con.asm):00095                                 bsr             con$putc                                                                ;erase from console
7A92 C620             (          con.asm):00096                                 ldb             #' '
7A94 8D1D             (          con.asm):00097                                 bsr             con$putc
7A96 C608             (          con.asm):00098                                 ldb             #BS
7A98 20E7             (          con.asm):00099                                 bra             @echo                                                                   ;and try again
                      (          con.asm):00100         ;
7A9A C10D             (          con.asm):00101         @eol?           cmpb    #CR
7A9C 2704             (          con.asm):00102                                 beq             @eol                                                                    ;if it's end of line
7A9E C10A             (          con.asm):00103                                 cmpb    #LF
7AA0 26C7             (          con.asm):00104                                 bne             @lp                                                                             ;else ignore it
7AA2 9F0F             (          con.asm):00105         @eol            stx             <con_buf_len                                                    ;save length of buffer
                      (          con.asm):00106         ;
7AA4 0D63             (          con.asm):00107                                 tst             <con_loading
7AA6 2703             (          con.asm):00108                                 beq             @done                                                                   ;if not loading
7AA8 BD7B59           (          con.asm):00109                                 jsr             con$pause                                                               ;else pause input
7AAB                  (          con.asm):00110         @done:
                      (          con.asm):00111                                 ; fall through into ...
                      (          con.asm):00112         ;
                      (          con.asm):00113         ; >>> Display newline
7AAB C60D             (          con.asm):00114         con$nl          ldb             #CR
7AAD 8D04             (          con.asm):00115                                 bsr             con$putc
7AAF C60A             (          con.asm):00116                                 ldb             #LF
7AB1 2000             (          con.asm):00117                                 bra             con$putc
                      (          con.asm):00118         ;
                      (          con.asm):00119         ; >>> Display a character
                      (          con.asm):00120         ; PASSED:  B = char to display
                      (          con.asm):00121         ; NOTE: Converts NLs to CRLFs
7AB3 C10A             (          con.asm):00122         con$putc        cmpb    #NL
7AB5 102600AC         (          con.asm):00123                                 lbne    con$outc                                                                ;if not a newline
7AB9 C60D             (          con.asm):00124                                 ldb             #CR                                                                             ;else output CR+LF
7ABB 1700A7           (          con.asm):00125                                 lbsr    con$outc
7ABE C60A             (          con.asm):00126                                 ldb             #LF
7AC0 1600A2           (          con.asm):00127                                 lbra    con$outc
                      (          con.asm):00128         
                      (          con.asm):00129         ; >>> Display line input prompt if needed.
7AC3                  (          con.asm):00130         con$prompt:
7AC3 0D63             (          con.asm):00131                                 tst             <con_loading
7AC5 260D             (          con.asm):00132                                 bne             @ret                                                                    ;not needed if loading
7AC7 960E             (          con.asm):00133                                 lda             <sexp$par$depth
7AC9 2709             (          con.asm):00134                                 beq             @ret                                                                    ;or if no unbalanced parens
                      (          con.asm):00135         ;
7ACB C620             (          con.asm):00136         @lp                     ldb             #' '                                                                    ;display 2 spaces/level
7ACD 8DE4             (          con.asm):00137                                 bsr             con$putc
7ACF 8DE2             (          con.asm):00138                                 bsr             con$putc
7AD1 4A               (          con.asm):00139                                 deca
7AD2 26F7             (          con.asm):00140                                 bne             @lp
                      (          con.asm):00141         ;
7AD4 39               (          con.asm):00142         @ret            rts
                      (          con.asm):00143         
                      (          con.asm):00144         ;@@@
                      (          con.asm):00145         ;@@@ CONSOLE OUTPUT
                      (          con.asm):00146         ;@@@
                      (          con.asm):00147         
                      (          con.asm):00148         ; >>> Display message
                      (          con.asm):00149         ; PASSED:  X = address of message, first byte is length
7AD5 3406             (          con.asm):00150         con$msg         pshs    d
7AD7 A680             (          con.asm):00151                                 lda             ,x+                                                                             ;A = length
7AD9 2005             (          con.asm):00152                                 bra             @end?
                      (          con.asm):00153         ;
7ADB E680             (          con.asm):00154         @lp                     ldb             ,x+                                                                             ;display next char
7ADD 8DD4             (          con.asm):00155                                 bsr             con$putc
7ADF 4A               (          con.asm):00156                                 deca
7AE0 26F9             (          con.asm):00157         @end?           bne             @lp                                                                             ;if not done
                      (          con.asm):00158         ;
7AE2 3506             (          con.asm):00159                                 puls    d
7AE4 39               (          con.asm):00160                                 rts
                      (          con.asm):00161         
                      (          con.asm):00162         ; >>> Display 16 bit unsigned hex integer
                      (          con.asm):00163         ; PASSED:  D = number to display
7AE5                  (          con.asm):00164         con$disp$hex$word:
7AE5 3406             (          con.asm):00165                                 pshs    d
7AE7 1F89             (          con.asm):00166                                 tfr             a,b
7AE9 8D02             (          con.asm):00167                                 bsr             con$disp$hex$byte                                               ;display high byte
7AEB 3506             (          con.asm):00168                                 puls    d
                      (          con.asm):00169                 ; fall through into ...
                      (          con.asm):00170         ;
                      (          con.asm):00171         ; >>> Display 8 bit unsigned hex integer
                      (          con.asm):00172         ; PASSED: B = byte to display
7AED                  (          con.asm):00173         con$disp$hex$byte:
7AED 3404             (          con.asm):00174                                 pshs    b
7AEF 54               (          con.asm):00175                                 lsrb
7AF0 54               (          con.asm):00176                                 lsrb
7AF1 54               (          con.asm):00177                                 lsrb
7AF2 54               (          con.asm):00178                                 lsrb
7AF3 8D02             (          con.asm):00179                                 bsr             @disp$nib                                                               ;display high nibble
7AF5 3504             (          con.asm):00180                                 puls    b
                      (          con.asm):00181         ;
7AF7 3404             (          con.asm):00182         @disp$nib       pshs    b                                                                               ;display low nibble of B
7AF9 C40F             (          con.asm):00183                                 andb    #$0f
7AFB CB30             (          con.asm):00184                                 addb    #'0'
7AFD C139             (          con.asm):00185                                 cmpb    #'9'
7AFF 2302             (          con.asm):00186                                 bls             @disp$dig                                                               ;if it's 0-9
7B01 CB07             (          con.asm):00187                                 addb    #'A'-'0'-10                                                             ;else it's A-F
7B03 8D60             (          con.asm):00188         @disp$dig       bsr             con$outc
7B05 3504             (          con.asm):00189                                 puls    b
7B07 39               (          con.asm):00190                                 rts
                      (          con.asm):00191         
                      (          con.asm):00192         ; >>> Display signed 16 bit integer value
                      (          con.asm):00193         ; PASSED:  D = integer value
                      (          con.asm):00194         ;
7B08                  (          con.asm):00195         con$disp$int$word:
7B08 4D               (          con.asm):00196                                 tsta
7B09 2A16             (          con.asm):00197                                 bpl             con$disp$ord$word                                               ;display positive numbers as-is
                      (          con.asm):00198         ;
7B0B 3404             (          con.asm):00199                                 pshs    b                                                                               ;else display sign
7B0D C62D             (          con.asm):00200                                 ldb             #'-'
7B0F BD7B65           (          con.asm):00201                                 jsr             con$outc
7B12 3504             (          con.asm):00202                                 puls    b
                      (          con.asm):00203         ;
7B14 3406             (          con.asm):00204                                 pshs    d
7B16 43               (          con.asm):00205                                 coma                                                                                    ;n = -n
7B17 53               (          con.asm):00206                                 comb
7B18 C30001           (          con.asm):00207                                 addd    #1
7B1B BD7B21           (          con.asm):00208                                 jsr             con$disp$ord$word
7B1E 3506             (          con.asm):00209                                 puls    d
7B20 39               (          con.asm):00210                                 rts
                      (          con.asm):00211         
                      (          con.asm):00212         ; >>> Display unsigned 16 bit integer value
                      (          con.asm):00213         ; PASSED:  D = integer value
                      (          con.asm):00214         ;
7B21                  (          con.asm):00215         con$disp$ord$word:
7B21 3416             (          con.asm):00216                                 pshs    x,d
7B23 8D03             (          con.asm):00217                                 bsr             @disp
7B25 3516             (          con.asm):00218                                 puls    d,x
7B27 39               (          con.asm):00219                                 rts
                      (          con.asm):00220         ;
7B28 1083000A         (          con.asm):00221         @disp           cmpd    #10
7B2C 250E             (          con.asm):00222                                 blo             @putd                                                                   ;if it's the highest digit
7B2E 8E000A           (          con.asm):00223                                 ldx             #10                                                                             ;else generate next digit
7B31 BD79E9           (          con.asm):00224                                 jsr             mod16
7B34 3404             (          con.asm):00225                                 pshs    b                                                                               ;save it
7B36 1F10             (          con.asm):00226                                 tfr             x,d
7B38 8DEE             (          con.asm):00227                                 bsr             @disp                                                                   ;show the higher digits
7B3A 3504             (          con.asm):00228                                 puls    b
7B3C CB30             (          con.asm):00229         @putd           addb    #'0'                                                                    ;display this digit
7B3E 2025             (          con.asm):00230                                 bra             con$outc
                      (          con.asm):00231         
                      (          con.asm):00232         ;@@@
                      (          con.asm):00233         ;@@@ RAW (HARDWARE) CONSOLE I/O
                      (          con.asm):00234         ;@@@
                      (          con.asm):00235         
                      (          con.asm):00236         ; >>> Console initialization (for Grant's 6 Chip Computer h/w)
                      (          con.asm):00237         ; 115200 baud, 8N1, RTS=0, RX INT enabled (in case wired for h/w handshake)
7B40 8603             (          con.asm):00238         con$init        lda             #ACIA_CTL_CDS_MRESET
7B42 B7A000           (          con.asm):00239                                 sta             G6CC_ACIA_CTL
7B45 8695             (          con.asm):00240                                 lda             #ACIA_CTL_CDS_BY_16+ACIA_CTL_WS_8N1+ACIA_CTL_TC_RTS0_TXI0+ACIA_CTL_RXI_1
7B47 B7A000           (          con.asm):00241                                 sta             G6CC_ACIA_CTL
7B4A 0F63             (          con.asm):00242                                 clr             <con_loading
7B4C 2011             (          con.asm):00243                                 bra             con$resume
                      (          con.asm):00244         
                      (          con.asm):00245         ; >>> Poll for raw console input (for Grant's 6 Chip Computer h/w)
                      (          con.asm):00246         ; RETURNS: NE,B = input char else EQ,B = 0 if none avail
7B4E F6A000           (          con.asm):00247         con$gotc        ldb             G6CC_ACIA_STAT
7B51 C401             (          con.asm):00248                                 andb    #ACIA_STAT_RDRF_MASK
7B53 2703             (          con.asm):00249                                 beq             @ret
7B55 F6A001           (          con.asm):00250                                 ldb             G6CC_ACIA_DATA
7B58 39               (          con.asm):00251         @ret            rts
                      (          con.asm):00252         
                      (          con.asm):00253         ; >>> Pause console input (set RTS=1)
7B59 86D5             (          con.asm):00254         con$pause       lda             #ACIA_CTL_CDS_BY_16+ACIA_CTL_WS_8N1+ACIA_CTL_TC_RTS1_TXI0+ACIA_CTL_RXI_1
7B5B B7A000           (          con.asm):00255                                 sta             G6CC_ACIA_CTL
7B5E 39               (          con.asm):00256                                 rts
                      (          con.asm):00257         
                      (          con.asm):00258         ; >>> Resume console input (set RTS=0)
7B5F 8695             (          con.asm):00259         con$resume      lda             #ACIA_CTL_CDS_BY_16+ACIA_CTL_WS_8N1+ACIA_CTL_TC_RTS0_TXI0+ACIA_CTL_RXI_1
7B61 B7A000           (          con.asm):00260                                 sta             G6CC_ACIA_CTL
7B64 39               (          con.asm):00261                                 rts
                      (          con.asm):00262         
                      (          con.asm):00263         ; >>> Grant's 6 Chip Computer: Output character
                      (          con.asm):00264         ; PASSED:  B = character to display
7B65 3402             (          con.asm):00265         con$outc        pshs    a
7B67 8602             (          con.asm):00266                                 lda             #ACIA_STAT_TDRE_MASK
7B69 B5A000           (          con.asm):00267         @wait           bita    G6CC_ACIA_STAT
7B6C 27FB             (          con.asm):00268                                 beq             @wait
7B6E F7A001           (          con.asm):00269                                 stb             G6CC_ACIA_DATA
7B71 3502             (          con.asm):00270                                 puls    a
7B73 39               (          con.asm):00271                                 rts
                      (    ./src/syl.asm):00360         
     7B74             (    ./src/syl.asm):00361         syl_end equ *
                      (    ./src/syl.asm):00362         
                      (    ./src/syl.asm):00363         ;@@@
                      (    ./src/syl.asm):00364         ;@@@ ASSERTIONS
                      (    ./src/syl.asm):00365         ;@@@
                      (    ./src/syl.asm):00366         
                      (    ./src/syl.asm):00367                 IFGT syl_end-CODE_END
                      (    ./src/syl.asm):00368                 ERROR "CODE DOESN'T FIT!"
                      (    ./src/syl.asm):00369                 ENDIF
                      (    ./src/syl.asm):00370         
                      (    ./src/syl.asm):00371                 IF CC_CAR_OFF
                      (    ./src/syl.asm):00372                 ERROR "Code optimizations require CC_CAR_OFF to be 0!"
                      (    ./src/syl.asm):00373                 ; This gives us a "free" CAR via [] in some cases
                      (    ./src/syl.asm):00374                 ENDIF
                      (    ./src/syl.asm):00375         
                      (    ./src/syl.asm):00376                 IF ATOM_NIL
                      (    ./src/syl.asm):00377                 ERROR "ATOM_NIL must be 0!"
                      (    ./src/syl.asm):00378                 ; So we can rely on EQ for end of lists among other optimizations
                      (    ./src/syl.asm):00379                 ENDIF
                      (    ./src/syl.asm):00380         
                      (    ./src/syl.asm):00381                 IF GC_MARK_POOL_SIZE&(4-1)
                      (    ./src/syl.asm):00382                 ERROR "GC Mark Pool init wants pool size a multiple of 4 for speed"
                      (    ./src/syl.asm):00383                 ENDIF
                      (    ./src/syl.asm):00384         
                      (    ./src/syl.asm):00385                         end
